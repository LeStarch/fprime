// ======================================================================
// \title  PassiveTestTesterBase.cpp
// \author Generated by fpp-to-cpp
// \brief  cpp file for PassiveTest component test harness base class
// ======================================================================

#include <cstdlib>
#include <cstring>

#include "FppTest/component/passive/PassiveTestTesterBase.hpp"

// ----------------------------------------------------------------------
// Component initialization
// ----------------------------------------------------------------------

void PassiveTestTesterBase ::
  init(NATIVE_INT_TYPE instance)
{
  // Initialize base class
  Fw::PassiveComponentBase::init(instance);

  // Connect input port cmdRegOut
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_from_cmdRegOut());
    port++
  ) {
    this->m_from_cmdRegOut[port].init();
    this->m_from_cmdRegOut[port].addCallComp(
      this,
      from_cmdRegOut_static
    );
    this->m_from_cmdRegOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_from_cmdRegOut[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_from_cmdRegOut[port].setObjName(portName);
#endif
  }

  // Connect input port cmdResponseOut
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_from_cmdResponseOut());
    port++
  ) {
    this->m_from_cmdResponseOut[port].init();
    this->m_from_cmdResponseOut[port].addCallComp(
      this,
      from_cmdResponseOut_static
    );
    this->m_from_cmdResponseOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_from_cmdResponseOut[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_from_cmdResponseOut[port].setObjName(portName);
#endif
  }

  // Connect input port eventOut
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_from_eventOut());
    port++
  ) {
    this->m_from_eventOut[port].init();
    this->m_from_eventOut[port].addCallComp(
      this,
      from_eventOut_static
    );
    this->m_from_eventOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_from_eventOut[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_from_eventOut[port].setObjName(portName);
#endif
  }

  // Connect input port prmGetOut
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_from_prmGetOut());
    port++
  ) {
    this->m_from_prmGetOut[port].init();
    this->m_from_prmGetOut[port].addCallComp(
      this,
      from_prmGetOut_static
    );
    this->m_from_prmGetOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_from_prmGetOut[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_from_prmGetOut[port].setObjName(portName);
#endif
  }

  // Connect input port prmSetOut
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_from_prmSetOut());
    port++
  ) {
    this->m_from_prmSetOut[port].init();
    this->m_from_prmSetOut[port].addCallComp(
      this,
      from_prmSetOut_static
    );
    this->m_from_prmSetOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_from_prmSetOut[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_from_prmSetOut[port].setObjName(portName);
#endif
  }

#if FW_ENABLE_TEXT_LOGGING == 1
  // Connect input port textEventOut
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_from_textEventOut());
    port++
  ) {
    this->m_from_textEventOut[port].init();
    this->m_from_textEventOut[port].addCallComp(
      this,
      from_textEventOut_static
    );
    this->m_from_textEventOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_from_textEventOut[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_from_textEventOut[port].setObjName(portName);
#endif
  }
#endif

  // Connect input port timeGetOut
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_from_timeGetOut());
    port++
  ) {
    this->m_from_timeGetOut[port].init();
    this->m_from_timeGetOut[port].addCallComp(
      this,
      from_timeGetOut_static
    );
    this->m_from_timeGetOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_from_timeGetOut[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_from_timeGetOut[port].setObjName(portName);
#endif
  }

  // Connect input port tlmOut
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_from_tlmOut());
    port++
  ) {
    this->m_from_tlmOut[port].init();
    this->m_from_tlmOut[port].addCallComp(
      this,
      from_tlmOut_static
    );
    this->m_from_tlmOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_from_tlmOut[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_from_tlmOut[port].setObjName(portName);
#endif
  }

  // Connect input port arrayArgsOut
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_from_arrayArgsOut());
    port++
  ) {
    this->m_from_arrayArgsOut[port].init();
    this->m_from_arrayArgsOut[port].addCallComp(
      this,
      from_arrayArgsOut_static
    );
    this->m_from_arrayArgsOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_from_arrayArgsOut[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_from_arrayArgsOut[port].setObjName(portName);
#endif
  }

  // Connect input port arrayReturnOut
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_from_arrayReturnOut());
    port++
  ) {
    this->m_from_arrayReturnOut[port].init();
    this->m_from_arrayReturnOut[port].addCallComp(
      this,
      from_arrayReturnOut_static
    );
    this->m_from_arrayReturnOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_from_arrayReturnOut[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_from_arrayReturnOut[port].setObjName(portName);
#endif
  }

  // Connect input port enumArgsOut
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_from_enumArgsOut());
    port++
  ) {
    this->m_from_enumArgsOut[port].init();
    this->m_from_enumArgsOut[port].addCallComp(
      this,
      from_enumArgsOut_static
    );
    this->m_from_enumArgsOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_from_enumArgsOut[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_from_enumArgsOut[port].setObjName(portName);
#endif
  }

  // Connect input port enumReturnOut
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_from_enumReturnOut());
    port++
  ) {
    this->m_from_enumReturnOut[port].init();
    this->m_from_enumReturnOut[port].addCallComp(
      this,
      from_enumReturnOut_static
    );
    this->m_from_enumReturnOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_from_enumReturnOut[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_from_enumReturnOut[port].setObjName(portName);
#endif
  }

  // Connect input port noArgsOut
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_from_noArgsOut());
    port++
  ) {
    this->m_from_noArgsOut[port].init();
    this->m_from_noArgsOut[port].addCallComp(
      this,
      from_noArgsOut_static
    );
    this->m_from_noArgsOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_from_noArgsOut[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_from_noArgsOut[port].setObjName(portName);
#endif
  }

  // Connect input port noArgsReturnOut
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_from_noArgsReturnOut());
    port++
  ) {
    this->m_from_noArgsReturnOut[port].init();
    this->m_from_noArgsReturnOut[port].addCallComp(
      this,
      from_noArgsReturnOut_static
    );
    this->m_from_noArgsReturnOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_from_noArgsReturnOut[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_from_noArgsReturnOut[port].setObjName(portName);
#endif
  }

  // Connect input port primitiveArgsOut
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_from_primitiveArgsOut());
    port++
  ) {
    this->m_from_primitiveArgsOut[port].init();
    this->m_from_primitiveArgsOut[port].addCallComp(
      this,
      from_primitiveArgsOut_static
    );
    this->m_from_primitiveArgsOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_from_primitiveArgsOut[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_from_primitiveArgsOut[port].setObjName(portName);
#endif
  }

  // Connect input port primitiveReturnOut
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_from_primitiveReturnOut());
    port++
  ) {
    this->m_from_primitiveReturnOut[port].init();
    this->m_from_primitiveReturnOut[port].addCallComp(
      this,
      from_primitiveReturnOut_static
    );
    this->m_from_primitiveReturnOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_from_primitiveReturnOut[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_from_primitiveReturnOut[port].setObjName(portName);
#endif
  }

  // Connect input port prmGetIn
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_from_prmGetIn());
    port++
  ) {
    this->m_from_prmGetIn[port].init();
    this->m_from_prmGetIn[port].addCallComp(
      this,
      from_prmGetIn_static
    );
    this->m_from_prmGetIn[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_from_prmGetIn[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_from_prmGetIn[port].setObjName(portName);
#endif
  }

  // Connect input port prmSetIn
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_from_prmSetIn());
    port++
  ) {
    this->m_from_prmSetIn[port].init();
    this->m_from_prmSetIn[port].addCallComp(
      this,
      from_prmSetIn_static
    );
    this->m_from_prmSetIn[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_from_prmSetIn[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_from_prmSetIn[port].setObjName(portName);
#endif
  }

  // Connect input port stringArgsOut
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_from_stringArgsOut());
    port++
  ) {
    this->m_from_stringArgsOut[port].init();
    this->m_from_stringArgsOut[port].addCallComp(
      this,
      from_stringArgsOut_static
    );
    this->m_from_stringArgsOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_from_stringArgsOut[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_from_stringArgsOut[port].setObjName(portName);
#endif
  }

  // Connect input port structArgsOut
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_from_structArgsOut());
    port++
  ) {
    this->m_from_structArgsOut[port].init();
    this->m_from_structArgsOut[port].addCallComp(
      this,
      from_structArgsOut_static
    );
    this->m_from_structArgsOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_from_structArgsOut[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_from_structArgsOut[port].setObjName(portName);
#endif
  }

  // Connect input port structReturnOut
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_from_structReturnOut());
    port++
  ) {
    this->m_from_structReturnOut[port].init();
    this->m_from_structReturnOut[port].addCallComp(
      this,
      from_structReturnOut_static
    );
    this->m_from_structReturnOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_from_structReturnOut[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_from_structReturnOut[port].setObjName(portName);
#endif
  }

  // Connect input port serialOut
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_from_serialOut());
    port++
  ) {
    this->m_from_serialOut[port].init();
    this->m_from_serialOut[port].addCallComp(
      this,
      from_serialOut_static
    );
    this->m_from_serialOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_from_serialOut[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_from_serialOut[port].setObjName(portName);
#endif
  }

  // Connect output port cmdIn
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_to_cmdIn());
    port++
  ) {
    this->m_to_cmdIn[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_to_cmdIn[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_to_cmdIn[port].setObjName(portName);
#endif
  }

  // Connect output port arrayArgsGuarded
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_to_arrayArgsGuarded());
    port++
  ) {
    this->m_to_arrayArgsGuarded[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_to_arrayArgsGuarded[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_to_arrayArgsGuarded[port].setObjName(portName);
#endif
  }

  // Connect output port arrayArgsSync
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_to_arrayArgsSync());
    port++
  ) {
    this->m_to_arrayArgsSync[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_to_arrayArgsSync[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_to_arrayArgsSync[port].setObjName(portName);
#endif
  }

  // Connect output port arrayReturnGuarded
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_to_arrayReturnGuarded());
    port++
  ) {
    this->m_to_arrayReturnGuarded[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_to_arrayReturnGuarded[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_to_arrayReturnGuarded[port].setObjName(portName);
#endif
  }

  // Connect output port arrayReturnSync
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_to_arrayReturnSync());
    port++
  ) {
    this->m_to_arrayReturnSync[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_to_arrayReturnSync[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_to_arrayReturnSync[port].setObjName(portName);
#endif
  }

  // Connect output port cmdOut
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_to_cmdOut());
    port++
  ) {
    this->m_to_cmdOut[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_to_cmdOut[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_to_cmdOut[port].setObjName(portName);
#endif
  }

  // Connect output port enumArgsGuarded
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_to_enumArgsGuarded());
    port++
  ) {
    this->m_to_enumArgsGuarded[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_to_enumArgsGuarded[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_to_enumArgsGuarded[port].setObjName(portName);
#endif
  }

  // Connect output port enumArgsSync
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_to_enumArgsSync());
    port++
  ) {
    this->m_to_enumArgsSync[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_to_enumArgsSync[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_to_enumArgsSync[port].setObjName(portName);
#endif
  }

  // Connect output port enumReturnGuarded
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_to_enumReturnGuarded());
    port++
  ) {
    this->m_to_enumReturnGuarded[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_to_enumReturnGuarded[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_to_enumReturnGuarded[port].setObjName(portName);
#endif
  }

  // Connect output port enumReturnSync
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_to_enumReturnSync());
    port++
  ) {
    this->m_to_enumReturnSync[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_to_enumReturnSync[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_to_enumReturnSync[port].setObjName(portName);
#endif
  }

  // Connect output port noArgsGuarded
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_to_noArgsGuarded());
    port++
  ) {
    this->m_to_noArgsGuarded[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_to_noArgsGuarded[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_to_noArgsGuarded[port].setObjName(portName);
#endif
  }

  // Connect output port noArgsReturnGuarded
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_to_noArgsReturnGuarded());
    port++
  ) {
    this->m_to_noArgsReturnGuarded[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_to_noArgsReturnGuarded[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_to_noArgsReturnGuarded[port].setObjName(portName);
#endif
  }

  // Connect output port noArgsReturnSync
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_to_noArgsReturnSync());
    port++
  ) {
    this->m_to_noArgsReturnSync[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_to_noArgsReturnSync[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_to_noArgsReturnSync[port].setObjName(portName);
#endif
  }

  // Connect output port noArgsSync
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_to_noArgsSync());
    port++
  ) {
    this->m_to_noArgsSync[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_to_noArgsSync[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_to_noArgsSync[port].setObjName(portName);
#endif
  }

  // Connect output port primitiveArgsGuarded
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_to_primitiveArgsGuarded());
    port++
  ) {
    this->m_to_primitiveArgsGuarded[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_to_primitiveArgsGuarded[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_to_primitiveArgsGuarded[port].setObjName(portName);
#endif
  }

  // Connect output port primitiveArgsSync
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_to_primitiveArgsSync());
    port++
  ) {
    this->m_to_primitiveArgsSync[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_to_primitiveArgsSync[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_to_primitiveArgsSync[port].setObjName(portName);
#endif
  }

  // Connect output port primitiveReturnGuarded
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_to_primitiveReturnGuarded());
    port++
  ) {
    this->m_to_primitiveReturnGuarded[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_to_primitiveReturnGuarded[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_to_primitiveReturnGuarded[port].setObjName(portName);
#endif
  }

  // Connect output port primitiveReturnSync
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_to_primitiveReturnSync());
    port++
  ) {
    this->m_to_primitiveReturnSync[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_to_primitiveReturnSync[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_to_primitiveReturnSync[port].setObjName(portName);
#endif
  }

  // Connect output port stringArgsGuarded
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_to_stringArgsGuarded());
    port++
  ) {
    this->m_to_stringArgsGuarded[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_to_stringArgsGuarded[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_to_stringArgsGuarded[port].setObjName(portName);
#endif
  }

  // Connect output port stringArgsSync
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_to_stringArgsSync());
    port++
  ) {
    this->m_to_stringArgsSync[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_to_stringArgsSync[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_to_stringArgsSync[port].setObjName(portName);
#endif
  }

  // Connect output port structArgsGuarded
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_to_structArgsGuarded());
    port++
  ) {
    this->m_to_structArgsGuarded[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_to_structArgsGuarded[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_to_structArgsGuarded[port].setObjName(portName);
#endif
  }

  // Connect output port structArgsSync
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_to_structArgsSync());
    port++
  ) {
    this->m_to_structArgsSync[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_to_structArgsSync[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_to_structArgsSync[port].setObjName(portName);
#endif
  }

  // Connect output port structReturnGuarded
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_to_structReturnGuarded());
    port++
  ) {
    this->m_to_structReturnGuarded[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_to_structReturnGuarded[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_to_structReturnGuarded[port].setObjName(portName);
#endif
  }

  // Connect output port structReturnSync
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_to_structReturnSync());
    port++
  ) {
    this->m_to_structReturnSync[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_to_structReturnSync[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_to_structReturnSync[port].setObjName(portName);
#endif
  }

  // Connect output port serialGuarded
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_to_serialGuarded());
    port++
  ) {
    this->m_to_serialGuarded[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_to_serialGuarded[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_to_serialGuarded[port].setObjName(portName);
#endif
  }

  // Connect output port serialSync
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_to_serialSync());
    port++
  ) {
    this->m_to_serialSync[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_to_serialSync[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_to_serialSync[port].setObjName(portName);
#endif
  }
}

// ----------------------------------------------------------------------
// Connectors for to ports
// ----------------------------------------------------------------------

void PassiveTestTesterBase ::
  connect_to_cmdIn(
      NATIVE_INT_TYPE portNum,
      Fw::InputCmdPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_to_cmdIn(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_cmdIn[portNum].addCallPort(port);
}

void PassiveTestTesterBase ::
  connect_to_arrayArgsGuarded(
      NATIVE_INT_TYPE portNum,
      InputArrayArgsPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_to_arrayArgsGuarded(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_arrayArgsGuarded[portNum].addCallPort(port);
}

void PassiveTestTesterBase ::
  connect_to_arrayArgsSync(
      NATIVE_INT_TYPE portNum,
      InputArrayArgsPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_to_arrayArgsSync(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_arrayArgsSync[portNum].addCallPort(port);
}

void PassiveTestTesterBase ::
  connect_to_arrayReturnGuarded(
      NATIVE_INT_TYPE portNum,
      InputArrayReturnPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_to_arrayReturnGuarded(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_arrayReturnGuarded[portNum].addCallPort(port);
}

void PassiveTestTesterBase ::
  connect_to_arrayReturnSync(
      NATIVE_INT_TYPE portNum,
      InputArrayReturnPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_to_arrayReturnSync(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_arrayReturnSync[portNum].addCallPort(port);
}

void PassiveTestTesterBase ::
  connect_to_cmdOut(
      NATIVE_INT_TYPE portNum,
      Fw::InputCmdPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_to_cmdOut(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_cmdOut[portNum].addCallPort(port);
}

void PassiveTestTesterBase ::
  connect_to_enumArgsGuarded(
      NATIVE_INT_TYPE portNum,
      InputEnumArgsPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_to_enumArgsGuarded(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_enumArgsGuarded[portNum].addCallPort(port);
}

void PassiveTestTesterBase ::
  connect_to_enumArgsSync(
      NATIVE_INT_TYPE portNum,
      InputEnumArgsPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_to_enumArgsSync(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_enumArgsSync[portNum].addCallPort(port);
}

void PassiveTestTesterBase ::
  connect_to_enumReturnGuarded(
      NATIVE_INT_TYPE portNum,
      InputEnumReturnPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_to_enumReturnGuarded(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_enumReturnGuarded[portNum].addCallPort(port);
}

void PassiveTestTesterBase ::
  connect_to_enumReturnSync(
      NATIVE_INT_TYPE portNum,
      InputEnumReturnPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_to_enumReturnSync(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_enumReturnSync[portNum].addCallPort(port);
}

void PassiveTestTesterBase ::
  connect_to_noArgsGuarded(
      NATIVE_INT_TYPE portNum,
      InputNoArgsPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_to_noArgsGuarded(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_noArgsGuarded[portNum].addCallPort(port);
}

void PassiveTestTesterBase ::
  connect_to_noArgsReturnGuarded(
      NATIVE_INT_TYPE portNum,
      InputNoArgsReturnPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_to_noArgsReturnGuarded(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_noArgsReturnGuarded[portNum].addCallPort(port);
}

void PassiveTestTesterBase ::
  connect_to_noArgsReturnSync(
      NATIVE_INT_TYPE portNum,
      InputNoArgsReturnPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_to_noArgsReturnSync(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_noArgsReturnSync[portNum].addCallPort(port);
}

void PassiveTestTesterBase ::
  connect_to_noArgsSync(
      NATIVE_INT_TYPE portNum,
      InputNoArgsPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_to_noArgsSync(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_noArgsSync[portNum].addCallPort(port);
}

void PassiveTestTesterBase ::
  connect_to_primitiveArgsGuarded(
      NATIVE_INT_TYPE portNum,
      InputPrimitiveArgsPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_to_primitiveArgsGuarded(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_primitiveArgsGuarded[portNum].addCallPort(port);
}

void PassiveTestTesterBase ::
  connect_to_primitiveArgsSync(
      NATIVE_INT_TYPE portNum,
      InputPrimitiveArgsPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_to_primitiveArgsSync(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_primitiveArgsSync[portNum].addCallPort(port);
}

void PassiveTestTesterBase ::
  connect_to_primitiveReturnGuarded(
      NATIVE_INT_TYPE portNum,
      InputPrimitiveReturnPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_to_primitiveReturnGuarded(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_primitiveReturnGuarded[portNum].addCallPort(port);
}

void PassiveTestTesterBase ::
  connect_to_primitiveReturnSync(
      NATIVE_INT_TYPE portNum,
      InputPrimitiveReturnPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_to_primitiveReturnSync(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_primitiveReturnSync[portNum].addCallPort(port);
}

void PassiveTestTesterBase ::
  connect_to_stringArgsGuarded(
      NATIVE_INT_TYPE portNum,
      InputStringArgsPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_to_stringArgsGuarded(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_stringArgsGuarded[portNum].addCallPort(port);
}

void PassiveTestTesterBase ::
  connect_to_stringArgsSync(
      NATIVE_INT_TYPE portNum,
      InputStringArgsPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_to_stringArgsSync(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_stringArgsSync[portNum].addCallPort(port);
}

void PassiveTestTesterBase ::
  connect_to_structArgsGuarded(
      NATIVE_INT_TYPE portNum,
      InputStructArgsPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_to_structArgsGuarded(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_structArgsGuarded[portNum].addCallPort(port);
}

void PassiveTestTesterBase ::
  connect_to_structArgsSync(
      NATIVE_INT_TYPE portNum,
      InputStructArgsPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_to_structArgsSync(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_structArgsSync[portNum].addCallPort(port);
}

void PassiveTestTesterBase ::
  connect_to_structReturnGuarded(
      NATIVE_INT_TYPE portNum,
      InputStructReturnPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_to_structReturnGuarded(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_structReturnGuarded[portNum].addCallPort(port);
}

void PassiveTestTesterBase ::
  connect_to_structReturnSync(
      NATIVE_INT_TYPE portNum,
      InputStructReturnPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_to_structReturnSync(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_structReturnSync[portNum].addCallPort(port);
}

void PassiveTestTesterBase ::
  connect_to_serialGuarded(
      NATIVE_INT_TYPE portNum,
      Fw::InputSerializePort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_to_serialGuarded(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_serialGuarded[portNum].registerSerialPort(port);
}

void PassiveTestTesterBase ::
  connect_to_serialSync(
      NATIVE_INT_TYPE portNum,
      Fw::InputSerializePort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_to_serialSync(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_serialSync[portNum].registerSerialPort(port);
}

// ----------------------------------------------------------------------
// Getters for from ports
// ----------------------------------------------------------------------

Fw::InputCmdRegPort* PassiveTestTesterBase ::
  get_from_cmdRegOut(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_from_cmdRegOut(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_from_cmdRegOut[portNum];
}

Fw::InputCmdResponsePort* PassiveTestTesterBase ::
  get_from_cmdResponseOut(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_from_cmdResponseOut(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_from_cmdResponseOut[portNum];
}

Fw::InputLogPort* PassiveTestTesterBase ::
  get_from_eventOut(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_from_eventOut(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_from_eventOut[portNum];
}

Fw::InputPrmGetPort* PassiveTestTesterBase ::
  get_from_prmGetOut(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_from_prmGetOut(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_from_prmGetOut[portNum];
}

Fw::InputPrmSetPort* PassiveTestTesterBase ::
  get_from_prmSetOut(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_from_prmSetOut(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_from_prmSetOut[portNum];
}

#if FW_ENABLE_TEXT_LOGGING == 1

Fw::InputLogTextPort* PassiveTestTesterBase ::
  get_from_textEventOut(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_from_textEventOut(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_from_textEventOut[portNum];
}

#endif

Fw::InputTimePort* PassiveTestTesterBase ::
  get_from_timeGetOut(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_from_timeGetOut(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_from_timeGetOut[portNum];
}

Fw::InputTlmPort* PassiveTestTesterBase ::
  get_from_tlmOut(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_from_tlmOut(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_from_tlmOut[portNum];
}

InputArrayArgsPort* PassiveTestTesterBase ::
  get_from_arrayArgsOut(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_from_arrayArgsOut(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_from_arrayArgsOut[portNum];
}

InputArrayReturnPort* PassiveTestTesterBase ::
  get_from_arrayReturnOut(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_from_arrayReturnOut(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_from_arrayReturnOut[portNum];
}

InputEnumArgsPort* PassiveTestTesterBase ::
  get_from_enumArgsOut(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_from_enumArgsOut(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_from_enumArgsOut[portNum];
}

InputEnumReturnPort* PassiveTestTesterBase ::
  get_from_enumReturnOut(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_from_enumReturnOut(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_from_enumReturnOut[portNum];
}

InputNoArgsPort* PassiveTestTesterBase ::
  get_from_noArgsOut(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_from_noArgsOut(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_from_noArgsOut[portNum];
}

InputNoArgsReturnPort* PassiveTestTesterBase ::
  get_from_noArgsReturnOut(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_from_noArgsReturnOut(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_from_noArgsReturnOut[portNum];
}

InputPrimitiveArgsPort* PassiveTestTesterBase ::
  get_from_primitiveArgsOut(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_from_primitiveArgsOut(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_from_primitiveArgsOut[portNum];
}

InputPrimitiveReturnPort* PassiveTestTesterBase ::
  get_from_primitiveReturnOut(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_from_primitiveReturnOut(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_from_primitiveReturnOut[portNum];
}

Fw::InputPrmGetPort* PassiveTestTesterBase ::
  get_from_prmGetIn(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_from_prmGetIn(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_from_prmGetIn[portNum];
}

Fw::InputPrmSetPort* PassiveTestTesterBase ::
  get_from_prmSetIn(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_from_prmSetIn(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_from_prmSetIn[portNum];
}

InputStringArgsPort* PassiveTestTesterBase ::
  get_from_stringArgsOut(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_from_stringArgsOut(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_from_stringArgsOut[portNum];
}

InputStructArgsPort* PassiveTestTesterBase ::
  get_from_structArgsOut(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_from_structArgsOut(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_from_structArgsOut[portNum];
}

InputStructReturnPort* PassiveTestTesterBase ::
  get_from_structReturnOut(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_from_structReturnOut(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_from_structReturnOut[portNum];
}

Fw::InputSerializePort* PassiveTestTesterBase ::
  get_from_serialOut(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_from_serialOut(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_from_serialOut[portNum];
}

// ----------------------------------------------------------------------
// Component construction and destruction
// ----------------------------------------------------------------------

PassiveTestTesterBase ::
  PassiveTestTesterBase(
      const char* const compName,
      const U32 maxHistorySize
  ) :
    Fw::PassiveComponentBase(compName),
    m_param_ParamBool_valid(Fw::ParamValid::UNINIT),
    m_param_ParamU32_valid(Fw::ParamValid::UNINIT),
    m_param_ParamString_valid(Fw::ParamValid::UNINIT),
    m_param_ParamEnum_valid(Fw::ParamValid::UNINIT),
    m_param_ParamArray_valid(Fw::ParamValid::UNINIT),
    m_param_ParamStruct_valid(Fw::ParamValid::UNINIT)
{
  // Initialize port histories
  this->fromPortHistory_arrayArgsOut = new History<FromPortEntry_arrayArgsOut>(maxHistorySize);
  this->fromPortHistory_arrayReturnOut = new History<FromPortEntry_arrayReturnOut>(maxHistorySize);
  this->fromPortHistory_enumArgsOut = new History<FromPortEntry_enumArgsOut>(maxHistorySize);
  this->fromPortHistory_enumReturnOut = new History<FromPortEntry_enumReturnOut>(maxHistorySize);
  this->fromPortHistory_primitiveArgsOut = new History<FromPortEntry_primitiveArgsOut>(maxHistorySize);
  this->fromPortHistory_primitiveReturnOut = new History<FromPortEntry_primitiveReturnOut>(maxHistorySize);
  this->fromPortHistory_prmGetIn = new History<FromPortEntry_prmGetIn>(maxHistorySize);
  this->fromPortHistory_prmSetIn = new History<FromPortEntry_prmSetIn>(maxHistorySize);
  this->fromPortHistory_stringArgsOut = new History<FromPortEntry_stringArgsOut>(maxHistorySize);
  this->fromPortHistory_structArgsOut = new History<FromPortEntry_structArgsOut>(maxHistorySize);
  this->fromPortHistory_structReturnOut = new History<FromPortEntry_structReturnOut>(maxHistorySize);

  // Initialize command history
  this->cmdResponseHistory = new History<CmdResponse>(maxHistorySize);

  // Initialize event histories
#if FW_ENABLE_TEXT_LOGGING
  this->textLogHistory = new History<TextLogEntry>(maxHistorySize);
#endif
  this->eventHistory_EventPrimitive = new History<EventEntry_EventPrimitive>(maxHistorySize);
  this->eventHistory_EventString = new History<EventEntry_EventString>(maxHistorySize);
  this->eventHistory_EventEnum = new History<EventEntry_EventEnum>(maxHistorySize);
  this->eventHistory_EventArray = new History<EventEntry_EventArray>(maxHistorySize);
  this->eventHistory_EventStruct = new History<EventEntry_EventStruct>(maxHistorySize);
  this->eventHistory_EventBool = new History<EventEntry_EventBool>(maxHistorySize);

  // Initialize telemetry histories
  this->tlmHistory_ChannelEnum = new History<TlmEntry_ChannelEnum>(maxHistorySize);
  this->tlmHistory_ChannelArray = new History<TlmEntry_ChannelArray>(maxHistorySize);
  this->tlmHistory_ChannelStruct = new History<TlmEntry_ChannelStruct>(maxHistorySize);
  this->tlmHistory_ChannelU32 = new History<TlmEntry_ChannelU32>(maxHistorySize);
  this->tlmHistory_ChannelF32 = new History<TlmEntry_ChannelF32>(maxHistorySize);
  this->tlmHistory_ChannelString = new History<TlmEntry_ChannelString>(maxHistorySize);

  // Clear history
  this->clearHistory();
}

PassiveTestTesterBase ::
  ~PassiveTestTesterBase()
{
  // Destroy port histories
  delete this->fromPortHistory_arrayArgsOut;
  delete this->fromPortHistory_arrayReturnOut;
  delete this->fromPortHistory_enumArgsOut;
  delete this->fromPortHistory_enumReturnOut;
  delete this->fromPortHistory_primitiveArgsOut;
  delete this->fromPortHistory_primitiveReturnOut;
  delete this->fromPortHistory_prmGetIn;
  delete this->fromPortHistory_prmSetIn;
  delete this->fromPortHistory_stringArgsOut;
  delete this->fromPortHistory_structArgsOut;
  delete this->fromPortHistory_structReturnOut;

  // Destroy command history
  delete this->cmdResponseHistory;

  // Destroy event histories
#if FW_ENABLE_TEXT_LOGGING
  delete this->textLogHistory;
#endif
  delete this->eventHistory_EventPrimitive;
  delete this->eventHistory_EventString;
  delete this->eventHistory_EventEnum;
  delete this->eventHistory_EventArray;
  delete this->eventHistory_EventStruct;
  delete this->eventHistory_EventBool;

  // Destroy telemetry histories
  delete this->tlmHistory_ChannelEnum;
  delete this->tlmHistory_ChannelArray;
  delete this->tlmHistory_ChannelStruct;
  delete this->tlmHistory_ChannelU32;
  delete this->tlmHistory_ChannelF32;
  delete this->tlmHistory_ChannelString;
}

// ----------------------------------------------------------------------
// Handler base-class functions for from ports
// ----------------------------------------------------------------------

void PassiveTestTesterBase ::
  from_arrayArgsOut_handlerBase(
      NATIVE_INT_TYPE portNum,
      const FormalParamArray& a,
      FormalParamArray& aRef
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_from_arrayArgsOut(),
    static_cast<FwAssertArgType>(portNum)
  );
  this->from_arrayArgsOut_handler(
    portNum,
    a,
    aRef
  );
}

FormalParamArray PassiveTestTesterBase ::
  from_arrayReturnOut_handlerBase(
      NATIVE_INT_TYPE portNum,
      const FormalParamArray& a,
      FormalParamArray& aRef
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_from_arrayReturnOut(),
    static_cast<FwAssertArgType>(portNum)
  );
  return this->from_arrayReturnOut_handler(
    portNum,
    a,
    aRef
  );
}

void PassiveTestTesterBase ::
  from_enumArgsOut_handlerBase(
      NATIVE_INT_TYPE portNum,
      const FormalParamEnum& en,
      FormalParamEnum& enRef
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_from_enumArgsOut(),
    static_cast<FwAssertArgType>(portNum)
  );
  this->from_enumArgsOut_handler(
    portNum,
    en,
    enRef
  );
}

FormalParamEnum PassiveTestTesterBase ::
  from_enumReturnOut_handlerBase(
      NATIVE_INT_TYPE portNum,
      const FormalParamEnum& en,
      FormalParamEnum& enRef
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_from_enumReturnOut(),
    static_cast<FwAssertArgType>(portNum)
  );
  return this->from_enumReturnOut_handler(
    portNum,
    en,
    enRef
  );
}

void PassiveTestTesterBase ::
  from_noArgsOut_handlerBase(NATIVE_INT_TYPE portNum)
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_from_noArgsOut(),
    static_cast<FwAssertArgType>(portNum)
  );
  this->from_noArgsOut_handler(portNum);
}

bool PassiveTestTesterBase ::
  from_noArgsReturnOut_handlerBase(NATIVE_INT_TYPE portNum)
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_from_noArgsReturnOut(),
    static_cast<FwAssertArgType>(portNum)
  );
  return this->from_noArgsReturnOut_handler(portNum);
}

void PassiveTestTesterBase ::
  from_primitiveArgsOut_handlerBase(
      NATIVE_INT_TYPE portNum,
      U32 u32,
      U32& u32Ref,
      F32 f32,
      F32& f32Ref,
      bool b,
      bool& bRef
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_from_primitiveArgsOut(),
    static_cast<FwAssertArgType>(portNum)
  );
  this->from_primitiveArgsOut_handler(
    portNum,
    u32,
    u32Ref,
    f32,
    f32Ref,
    b,
    bRef
  );
}

U32 PassiveTestTesterBase ::
  from_primitiveReturnOut_handlerBase(
      NATIVE_INT_TYPE portNum,
      U32 u32,
      U32& u32Ref,
      F32 f32,
      F32& f32Ref,
      bool b,
      bool& bRef
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_from_primitiveReturnOut(),
    static_cast<FwAssertArgType>(portNum)
  );
  return this->from_primitiveReturnOut_handler(
    portNum,
    u32,
    u32Ref,
    f32,
    f32Ref,
    b,
    bRef
  );
}

Fw::ParamValid PassiveTestTesterBase ::
  from_prmGetIn_handlerBase(
      NATIVE_INT_TYPE portNum,
      FwPrmIdType id,
      Fw::ParamBuffer& val
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_from_prmGetIn(),
    static_cast<FwAssertArgType>(portNum)
  );
  return this->from_prmGetIn_handler(
    portNum,
    id,
    val
  );
}

void PassiveTestTesterBase ::
  from_prmSetIn_handlerBase(
      NATIVE_INT_TYPE portNum,
      FwPrmIdType id,
      Fw::ParamBuffer& val
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_from_prmSetIn(),
    static_cast<FwAssertArgType>(portNum)
  );
  this->from_prmSetIn_handler(
    portNum,
    id,
    val
  );
}

void PassiveTestTesterBase ::
  from_stringArgsOut_handlerBase(
      NATIVE_INT_TYPE portNum,
      const StringArgsPortStrings::StringSize80& str80,
      StringArgsPortStrings::StringSize80& str80Ref,
      const StringArgsPortStrings::StringSize100& str100,
      StringArgsPortStrings::StringSize100& str100Ref
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_from_stringArgsOut(),
    static_cast<FwAssertArgType>(portNum)
  );
  this->from_stringArgsOut_handler(
    portNum,
    str80,
    str80Ref,
    str100,
    str100Ref
  );
}

void PassiveTestTesterBase ::
  from_structArgsOut_handlerBase(
      NATIVE_INT_TYPE portNum,
      const FormalParamStruct& s,
      FormalParamStruct& sRef
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_from_structArgsOut(),
    static_cast<FwAssertArgType>(portNum)
  );
  this->from_structArgsOut_handler(
    portNum,
    s,
    sRef
  );
}

FormalParamStruct PassiveTestTesterBase ::
  from_structReturnOut_handlerBase(
      NATIVE_INT_TYPE portNum,
      const FormalParamStruct& s,
      FormalParamStruct& sRef
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_from_structReturnOut(),
    static_cast<FwAssertArgType>(portNum)
  );
  return this->from_structReturnOut_handler(
    portNum,
    s,
    sRef
  );
}

void PassiveTestTesterBase ::
  from_serialOut_handlerBase(
      NATIVE_INT_TYPE portNum,
      Fw::SerializeBufferBase& buffer
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_from_serialOut(),
    static_cast<FwAssertArgType>(portNum)
  );
  this->from_serialOut_handler(
    portNum,
    buffer
  );
}

// ----------------------------------------------------------------------
// Invocation functions for to ports
// ----------------------------------------------------------------------

void PassiveTestTesterBase ::
  invoke_to_arrayArgsGuarded(
      NATIVE_INT_TYPE portNum,
      const FormalParamArray& a,
      FormalParamArray& aRef
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_to_arrayArgsGuarded(),
    static_cast<FwAssertArgType>(portNum)
  );
  this->m_to_arrayArgsGuarded[portNum].invoke(
    a,
    aRef
  );
}

void PassiveTestTesterBase ::
  invoke_to_arrayArgsSync(
      NATIVE_INT_TYPE portNum,
      const FormalParamArray& a,
      FormalParamArray& aRef
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_to_arrayArgsSync(),
    static_cast<FwAssertArgType>(portNum)
  );
  this->m_to_arrayArgsSync[portNum].invoke(
    a,
    aRef
  );
}

FormalParamArray PassiveTestTesterBase ::
  invoke_to_arrayReturnGuarded(
      NATIVE_INT_TYPE portNum,
      const FormalParamArray& a,
      FormalParamArray& aRef
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_to_arrayReturnGuarded(),
    static_cast<FwAssertArgType>(portNum)
  );
  return this->m_to_arrayReturnGuarded[portNum].invoke(
    a,
    aRef
  );
}

FormalParamArray PassiveTestTesterBase ::
  invoke_to_arrayReturnSync(
      NATIVE_INT_TYPE portNum,
      const FormalParamArray& a,
      FormalParamArray& aRef
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_to_arrayReturnSync(),
    static_cast<FwAssertArgType>(portNum)
  );
  return this->m_to_arrayReturnSync[portNum].invoke(
    a,
    aRef
  );
}

void PassiveTestTesterBase ::
  invoke_to_cmdOut(
      NATIVE_INT_TYPE portNum,
      FwOpcodeType opCode,
      U32 cmdSeq,
      Fw::CmdArgBuffer& args
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_to_cmdOut(),
    static_cast<FwAssertArgType>(portNum)
  );
  this->m_to_cmdOut[portNum].invoke(
    opCode,
    cmdSeq,
    args
  );
}

void PassiveTestTesterBase ::
  invoke_to_enumArgsGuarded(
      NATIVE_INT_TYPE portNum,
      const FormalParamEnum& en,
      FormalParamEnum& enRef
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_to_enumArgsGuarded(),
    static_cast<FwAssertArgType>(portNum)
  );
  this->m_to_enumArgsGuarded[portNum].invoke(
    en,
    enRef
  );
}

void PassiveTestTesterBase ::
  invoke_to_enumArgsSync(
      NATIVE_INT_TYPE portNum,
      const FormalParamEnum& en,
      FormalParamEnum& enRef
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_to_enumArgsSync(),
    static_cast<FwAssertArgType>(portNum)
  );
  this->m_to_enumArgsSync[portNum].invoke(
    en,
    enRef
  );
}

FormalParamEnum PassiveTestTesterBase ::
  invoke_to_enumReturnGuarded(
      NATIVE_INT_TYPE portNum,
      const FormalParamEnum& en,
      FormalParamEnum& enRef
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_to_enumReturnGuarded(),
    static_cast<FwAssertArgType>(portNum)
  );
  return this->m_to_enumReturnGuarded[portNum].invoke(
    en,
    enRef
  );
}

FormalParamEnum PassiveTestTesterBase ::
  invoke_to_enumReturnSync(
      NATIVE_INT_TYPE portNum,
      const FormalParamEnum& en,
      FormalParamEnum& enRef
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_to_enumReturnSync(),
    static_cast<FwAssertArgType>(portNum)
  );
  return this->m_to_enumReturnSync[portNum].invoke(
    en,
    enRef
  );
}

void PassiveTestTesterBase ::
  invoke_to_noArgsGuarded(NATIVE_INT_TYPE portNum)
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_to_noArgsGuarded(),
    static_cast<FwAssertArgType>(portNum)
  );
  this->m_to_noArgsGuarded[portNum].invoke();
}

bool PassiveTestTesterBase ::
  invoke_to_noArgsReturnGuarded(NATIVE_INT_TYPE portNum)
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_to_noArgsReturnGuarded(),
    static_cast<FwAssertArgType>(portNum)
  );
  return this->m_to_noArgsReturnGuarded[portNum].invoke();
}

bool PassiveTestTesterBase ::
  invoke_to_noArgsReturnSync(NATIVE_INT_TYPE portNum)
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_to_noArgsReturnSync(),
    static_cast<FwAssertArgType>(portNum)
  );
  return this->m_to_noArgsReturnSync[portNum].invoke();
}

void PassiveTestTesterBase ::
  invoke_to_noArgsSync(NATIVE_INT_TYPE portNum)
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_to_noArgsSync(),
    static_cast<FwAssertArgType>(portNum)
  );
  this->m_to_noArgsSync[portNum].invoke();
}

void PassiveTestTesterBase ::
  invoke_to_primitiveArgsGuarded(
      NATIVE_INT_TYPE portNum,
      U32 u32,
      U32& u32Ref,
      F32 f32,
      F32& f32Ref,
      bool b,
      bool& bRef
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_to_primitiveArgsGuarded(),
    static_cast<FwAssertArgType>(portNum)
  );
  this->m_to_primitiveArgsGuarded[portNum].invoke(
    u32,
    u32Ref,
    f32,
    f32Ref,
    b,
    bRef
  );
}

void PassiveTestTesterBase ::
  invoke_to_primitiveArgsSync(
      NATIVE_INT_TYPE portNum,
      U32 u32,
      U32& u32Ref,
      F32 f32,
      F32& f32Ref,
      bool b,
      bool& bRef
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_to_primitiveArgsSync(),
    static_cast<FwAssertArgType>(portNum)
  );
  this->m_to_primitiveArgsSync[portNum].invoke(
    u32,
    u32Ref,
    f32,
    f32Ref,
    b,
    bRef
  );
}

U32 PassiveTestTesterBase ::
  invoke_to_primitiveReturnGuarded(
      NATIVE_INT_TYPE portNum,
      U32 u32,
      U32& u32Ref,
      F32 f32,
      F32& f32Ref,
      bool b,
      bool& bRef
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_to_primitiveReturnGuarded(),
    static_cast<FwAssertArgType>(portNum)
  );
  return this->m_to_primitiveReturnGuarded[portNum].invoke(
    u32,
    u32Ref,
    f32,
    f32Ref,
    b,
    bRef
  );
}

U32 PassiveTestTesterBase ::
  invoke_to_primitiveReturnSync(
      NATIVE_INT_TYPE portNum,
      U32 u32,
      U32& u32Ref,
      F32 f32,
      F32& f32Ref,
      bool b,
      bool& bRef
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_to_primitiveReturnSync(),
    static_cast<FwAssertArgType>(portNum)
  );
  return this->m_to_primitiveReturnSync[portNum].invoke(
    u32,
    u32Ref,
    f32,
    f32Ref,
    b,
    bRef
  );
}

void PassiveTestTesterBase ::
  invoke_to_stringArgsGuarded(
      NATIVE_INT_TYPE portNum,
      const StringArgsPortStrings::StringSize80& str80,
      StringArgsPortStrings::StringSize80& str80Ref,
      const StringArgsPortStrings::StringSize100& str100,
      StringArgsPortStrings::StringSize100& str100Ref
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_to_stringArgsGuarded(),
    static_cast<FwAssertArgType>(portNum)
  );
  this->m_to_stringArgsGuarded[portNum].invoke(
    str80,
    str80Ref,
    str100,
    str100Ref
  );
}

void PassiveTestTesterBase ::
  invoke_to_stringArgsSync(
      NATIVE_INT_TYPE portNum,
      const StringArgsPortStrings::StringSize80& str80,
      StringArgsPortStrings::StringSize80& str80Ref,
      const StringArgsPortStrings::StringSize100& str100,
      StringArgsPortStrings::StringSize100& str100Ref
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_to_stringArgsSync(),
    static_cast<FwAssertArgType>(portNum)
  );
  this->m_to_stringArgsSync[portNum].invoke(
    str80,
    str80Ref,
    str100,
    str100Ref
  );
}

void PassiveTestTesterBase ::
  invoke_to_structArgsGuarded(
      NATIVE_INT_TYPE portNum,
      const FormalParamStruct& s,
      FormalParamStruct& sRef
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_to_structArgsGuarded(),
    static_cast<FwAssertArgType>(portNum)
  );
  this->m_to_structArgsGuarded[portNum].invoke(
    s,
    sRef
  );
}

void PassiveTestTesterBase ::
  invoke_to_structArgsSync(
      NATIVE_INT_TYPE portNum,
      const FormalParamStruct& s,
      FormalParamStruct& sRef
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_to_structArgsSync(),
    static_cast<FwAssertArgType>(portNum)
  );
  this->m_to_structArgsSync[portNum].invoke(
    s,
    sRef
  );
}

FormalParamStruct PassiveTestTesterBase ::
  invoke_to_structReturnGuarded(
      NATIVE_INT_TYPE portNum,
      const FormalParamStruct& s,
      FormalParamStruct& sRef
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_to_structReturnGuarded(),
    static_cast<FwAssertArgType>(portNum)
  );
  return this->m_to_structReturnGuarded[portNum].invoke(
    s,
    sRef
  );
}

FormalParamStruct PassiveTestTesterBase ::
  invoke_to_structReturnSync(
      NATIVE_INT_TYPE portNum,
      const FormalParamStruct& s,
      FormalParamStruct& sRef
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_to_structReturnSync(),
    static_cast<FwAssertArgType>(portNum)
  );
  return this->m_to_structReturnSync[portNum].invoke(
    s,
    sRef
  );
}

void PassiveTestTesterBase ::
  invoke_to_serialGuarded(
      NATIVE_INT_TYPE portNum,
      Fw::SerializeBufferBase& buffer
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_to_serialGuarded(),
    static_cast<FwAssertArgType>(portNum)
  );
  this->m_to_serialGuarded[portNum].invokeSerial(
    buffer
  );
}

void PassiveTestTesterBase ::
  invoke_to_serialSync(
      NATIVE_INT_TYPE portNum,
      Fw::SerializeBufferBase& buffer
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_to_serialSync(),
    static_cast<FwAssertArgType>(portNum)
  );
  this->m_to_serialSync[portNum].invokeSerial(
    buffer
  );
}

// ----------------------------------------------------------------------
// Getters for port counts
// ----------------------------------------------------------------------

NATIVE_INT_TYPE PassiveTestTesterBase ::
  getNum_to_cmdIn() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_to_cmdIn));
}

NATIVE_INT_TYPE PassiveTestTesterBase ::
  getNum_to_arrayArgsGuarded() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_to_arrayArgsGuarded));
}

NATIVE_INT_TYPE PassiveTestTesterBase ::
  getNum_to_arrayArgsSync() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_to_arrayArgsSync));
}

NATIVE_INT_TYPE PassiveTestTesterBase ::
  getNum_to_arrayReturnGuarded() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_to_arrayReturnGuarded));
}

NATIVE_INT_TYPE PassiveTestTesterBase ::
  getNum_to_arrayReturnSync() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_to_arrayReturnSync));
}

NATIVE_INT_TYPE PassiveTestTesterBase ::
  getNum_to_cmdOut() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_to_cmdOut));
}

NATIVE_INT_TYPE PassiveTestTesterBase ::
  getNum_to_enumArgsGuarded() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_to_enumArgsGuarded));
}

NATIVE_INT_TYPE PassiveTestTesterBase ::
  getNum_to_enumArgsSync() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_to_enumArgsSync));
}

NATIVE_INT_TYPE PassiveTestTesterBase ::
  getNum_to_enumReturnGuarded() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_to_enumReturnGuarded));
}

NATIVE_INT_TYPE PassiveTestTesterBase ::
  getNum_to_enumReturnSync() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_to_enumReturnSync));
}

NATIVE_INT_TYPE PassiveTestTesterBase ::
  getNum_to_noArgsGuarded() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_to_noArgsGuarded));
}

NATIVE_INT_TYPE PassiveTestTesterBase ::
  getNum_to_noArgsReturnGuarded() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_to_noArgsReturnGuarded));
}

NATIVE_INT_TYPE PassiveTestTesterBase ::
  getNum_to_noArgsReturnSync() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_to_noArgsReturnSync));
}

NATIVE_INT_TYPE PassiveTestTesterBase ::
  getNum_to_noArgsSync() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_to_noArgsSync));
}

NATIVE_INT_TYPE PassiveTestTesterBase ::
  getNum_to_primitiveArgsGuarded() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_to_primitiveArgsGuarded));
}

NATIVE_INT_TYPE PassiveTestTesterBase ::
  getNum_to_primitiveArgsSync() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_to_primitiveArgsSync));
}

NATIVE_INT_TYPE PassiveTestTesterBase ::
  getNum_to_primitiveReturnGuarded() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_to_primitiveReturnGuarded));
}

NATIVE_INT_TYPE PassiveTestTesterBase ::
  getNum_to_primitiveReturnSync() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_to_primitiveReturnSync));
}

NATIVE_INT_TYPE PassiveTestTesterBase ::
  getNum_to_stringArgsGuarded() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_to_stringArgsGuarded));
}

NATIVE_INT_TYPE PassiveTestTesterBase ::
  getNum_to_stringArgsSync() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_to_stringArgsSync));
}

NATIVE_INT_TYPE PassiveTestTesterBase ::
  getNum_to_structArgsGuarded() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_to_structArgsGuarded));
}

NATIVE_INT_TYPE PassiveTestTesterBase ::
  getNum_to_structArgsSync() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_to_structArgsSync));
}

NATIVE_INT_TYPE PassiveTestTesterBase ::
  getNum_to_structReturnGuarded() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_to_structReturnGuarded));
}

NATIVE_INT_TYPE PassiveTestTesterBase ::
  getNum_to_structReturnSync() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_to_structReturnSync));
}

NATIVE_INT_TYPE PassiveTestTesterBase ::
  getNum_to_serialGuarded() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_to_serialGuarded));
}

NATIVE_INT_TYPE PassiveTestTesterBase ::
  getNum_to_serialSync() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_to_serialSync));
}

NATIVE_INT_TYPE PassiveTestTesterBase ::
  getNum_from_cmdRegOut() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_from_cmdRegOut));
}

NATIVE_INT_TYPE PassiveTestTesterBase ::
  getNum_from_cmdResponseOut() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_from_cmdResponseOut));
}

NATIVE_INT_TYPE PassiveTestTesterBase ::
  getNum_from_eventOut() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_from_eventOut));
}

NATIVE_INT_TYPE PassiveTestTesterBase ::
  getNum_from_prmGetOut() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_from_prmGetOut));
}

NATIVE_INT_TYPE PassiveTestTesterBase ::
  getNum_from_prmSetOut() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_from_prmSetOut));
}

#if FW_ENABLE_TEXT_LOGGING == 1

NATIVE_INT_TYPE PassiveTestTesterBase ::
  getNum_from_textEventOut() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_from_textEventOut));
}

#endif

NATIVE_INT_TYPE PassiveTestTesterBase ::
  getNum_from_timeGetOut() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_from_timeGetOut));
}

NATIVE_INT_TYPE PassiveTestTesterBase ::
  getNum_from_tlmOut() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_from_tlmOut));
}

NATIVE_INT_TYPE PassiveTestTesterBase ::
  getNum_from_arrayArgsOut() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_from_arrayArgsOut));
}

NATIVE_INT_TYPE PassiveTestTesterBase ::
  getNum_from_arrayReturnOut() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_from_arrayReturnOut));
}

NATIVE_INT_TYPE PassiveTestTesterBase ::
  getNum_from_enumArgsOut() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_from_enumArgsOut));
}

NATIVE_INT_TYPE PassiveTestTesterBase ::
  getNum_from_enumReturnOut() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_from_enumReturnOut));
}

NATIVE_INT_TYPE PassiveTestTesterBase ::
  getNum_from_noArgsOut() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_from_noArgsOut));
}

NATIVE_INT_TYPE PassiveTestTesterBase ::
  getNum_from_noArgsReturnOut() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_from_noArgsReturnOut));
}

NATIVE_INT_TYPE PassiveTestTesterBase ::
  getNum_from_primitiveArgsOut() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_from_primitiveArgsOut));
}

NATIVE_INT_TYPE PassiveTestTesterBase ::
  getNum_from_primitiveReturnOut() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_from_primitiveReturnOut));
}

NATIVE_INT_TYPE PassiveTestTesterBase ::
  getNum_from_prmGetIn() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_from_prmGetIn));
}

NATIVE_INT_TYPE PassiveTestTesterBase ::
  getNum_from_prmSetIn() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_from_prmSetIn));
}

NATIVE_INT_TYPE PassiveTestTesterBase ::
  getNum_from_stringArgsOut() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_from_stringArgsOut));
}

NATIVE_INT_TYPE PassiveTestTesterBase ::
  getNum_from_structArgsOut() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_from_structArgsOut));
}

NATIVE_INT_TYPE PassiveTestTesterBase ::
  getNum_from_structReturnOut() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_from_structReturnOut));
}

NATIVE_INT_TYPE PassiveTestTesterBase ::
  getNum_from_serialOut() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_from_serialOut));
}

// ----------------------------------------------------------------------
// Connection status queries for to ports
// ----------------------------------------------------------------------

bool PassiveTestTesterBase ::
  isConnected_to_cmdIn(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_to_cmdIn(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_cmdIn[portNum].isConnected();
}

bool PassiveTestTesterBase ::
  isConnected_to_arrayArgsGuarded(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_to_arrayArgsGuarded(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_arrayArgsGuarded[portNum].isConnected();
}

bool PassiveTestTesterBase ::
  isConnected_to_arrayArgsSync(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_to_arrayArgsSync(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_arrayArgsSync[portNum].isConnected();
}

bool PassiveTestTesterBase ::
  isConnected_to_arrayReturnGuarded(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_to_arrayReturnGuarded(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_arrayReturnGuarded[portNum].isConnected();
}

bool PassiveTestTesterBase ::
  isConnected_to_arrayReturnSync(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_to_arrayReturnSync(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_arrayReturnSync[portNum].isConnected();
}

bool PassiveTestTesterBase ::
  isConnected_to_cmdOut(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_to_cmdOut(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_cmdOut[portNum].isConnected();
}

bool PassiveTestTesterBase ::
  isConnected_to_enumArgsGuarded(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_to_enumArgsGuarded(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_enumArgsGuarded[portNum].isConnected();
}

bool PassiveTestTesterBase ::
  isConnected_to_enumArgsSync(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_to_enumArgsSync(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_enumArgsSync[portNum].isConnected();
}

bool PassiveTestTesterBase ::
  isConnected_to_enumReturnGuarded(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_to_enumReturnGuarded(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_enumReturnGuarded[portNum].isConnected();
}

bool PassiveTestTesterBase ::
  isConnected_to_enumReturnSync(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_to_enumReturnSync(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_enumReturnSync[portNum].isConnected();
}

bool PassiveTestTesterBase ::
  isConnected_to_noArgsGuarded(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_to_noArgsGuarded(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_noArgsGuarded[portNum].isConnected();
}

bool PassiveTestTesterBase ::
  isConnected_to_noArgsReturnGuarded(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_to_noArgsReturnGuarded(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_noArgsReturnGuarded[portNum].isConnected();
}

bool PassiveTestTesterBase ::
  isConnected_to_noArgsReturnSync(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_to_noArgsReturnSync(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_noArgsReturnSync[portNum].isConnected();
}

bool PassiveTestTesterBase ::
  isConnected_to_noArgsSync(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_to_noArgsSync(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_noArgsSync[portNum].isConnected();
}

bool PassiveTestTesterBase ::
  isConnected_to_primitiveArgsGuarded(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_to_primitiveArgsGuarded(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_primitiveArgsGuarded[portNum].isConnected();
}

bool PassiveTestTesterBase ::
  isConnected_to_primitiveArgsSync(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_to_primitiveArgsSync(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_primitiveArgsSync[portNum].isConnected();
}

bool PassiveTestTesterBase ::
  isConnected_to_primitiveReturnGuarded(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_to_primitiveReturnGuarded(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_primitiveReturnGuarded[portNum].isConnected();
}

bool PassiveTestTesterBase ::
  isConnected_to_primitiveReturnSync(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_to_primitiveReturnSync(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_primitiveReturnSync[portNum].isConnected();
}

bool PassiveTestTesterBase ::
  isConnected_to_stringArgsGuarded(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_to_stringArgsGuarded(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_stringArgsGuarded[portNum].isConnected();
}

bool PassiveTestTesterBase ::
  isConnected_to_stringArgsSync(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_to_stringArgsSync(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_stringArgsSync[portNum].isConnected();
}

bool PassiveTestTesterBase ::
  isConnected_to_structArgsGuarded(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_to_structArgsGuarded(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_structArgsGuarded[portNum].isConnected();
}

bool PassiveTestTesterBase ::
  isConnected_to_structArgsSync(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_to_structArgsSync(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_structArgsSync[portNum].isConnected();
}

bool PassiveTestTesterBase ::
  isConnected_to_structReturnGuarded(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_to_structReturnGuarded(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_structReturnGuarded[portNum].isConnected();
}

bool PassiveTestTesterBase ::
  isConnected_to_structReturnSync(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_to_structReturnSync(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_structReturnSync[portNum].isConnected();
}

bool PassiveTestTesterBase ::
  isConnected_to_serialGuarded(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_to_serialGuarded(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_serialGuarded[portNum].isConnected();
}

bool PassiveTestTesterBase ::
  isConnected_to_serialSync(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_to_serialSync(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_serialSync[portNum].isConnected();
}

// ----------------------------------------------------------------------
// Functions for testing commands
// ----------------------------------------------------------------------

void PassiveTestTesterBase ::
  cmdResponseIn(
      FwOpcodeType opCode,
      U32 cmdSeq,
      Fw::CmdResponse response
  )
{
  CmdResponse e = { opCode, cmdSeq, response };
  this->cmdResponseHistory->push_back(e);
}

void PassiveTestTesterBase ::
  sendRawCmd(
      FwOpcodeType opCode,
      U32 cmdSeq,
      Fw::CmdArgBuffer& buf
  )
{
  const U32 idBase = this->getIdBase();
  FwOpcodeType _opcode = opCode + idBase;
  if (this->m_to_cmdIn[0].isConnected()) {
    this->m_to_cmdIn[0].invoke(
      _opcode,
      cmdSeq,
      buf
    );
  }
  else {
    printf("Test Command Output port not connected!\n");
  }
}

void PassiveTestTesterBase ::
  sendCmd_CMD_NO_ARGS(
      const NATIVE_INT_TYPE instance,
      U32 cmdSeq
  )
{
  Fw::CmdArgBuffer buf;

  // Call output command port
  FwOpcodeType _opcode;
  const U32 idBase = this->getIdBase();
  _opcode = PassiveTestComponentBase::OPCODE_CMD_NO_ARGS + idBase;

  if (this->m_to_cmdIn[0].isConnected()) {
    this->m_to_cmdIn[0].invoke(
      _opcode,
      cmdSeq,
      buf
    );
  }
  else {
    printf("Test Command Output port not connected!\n");
  }
}

void PassiveTestTesterBase ::
  sendCmd_CMD_PRIMITIVE(
      const NATIVE_INT_TYPE instance,
      U32 cmdSeq,
      U32 u32_1,
      U32 u32_2,
      F32 f32_1,
      F32 f32_2,
      bool b1,
      bool b2
  )
{
  // Serialize arguments
  Fw::CmdArgBuffer buf;
  Fw::SerializeStatus _status;

  _status = buf.serialize(u32_1);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  _status = buf.serialize(u32_2);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  _status = buf.serialize(f32_1);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  _status = buf.serialize(f32_2);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  _status = buf.serialize(b1);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  _status = buf.serialize(b2);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Call output command port
  FwOpcodeType _opcode;
  const U32 idBase = this->getIdBase();
  _opcode = PassiveTestComponentBase::OPCODE_CMD_PRIMITIVE + idBase;

  if (this->m_to_cmdIn[0].isConnected()) {
    this->m_to_cmdIn[0].invoke(
      _opcode,
      cmdSeq,
      buf
    );
  }
  else {
    printf("Test Command Output port not connected!\n");
  }
}

void PassiveTestTesterBase ::
  sendCmd_CMD_STRINGS(
      const NATIVE_INT_TYPE instance,
      U32 cmdSeq,
      const Fw::CmdStringArg& str1,
      const Fw::CmdStringArg& str2
  )
{
  // Serialize arguments
  Fw::CmdArgBuffer buf;
  Fw::SerializeStatus _status;

  _status = buf.serialize(str1);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  _status = buf.serialize(str2);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Call output command port
  FwOpcodeType _opcode;
  const U32 idBase = this->getIdBase();
  _opcode = PassiveTestComponentBase::OPCODE_CMD_STRINGS + idBase;

  if (this->m_to_cmdIn[0].isConnected()) {
    this->m_to_cmdIn[0].invoke(
      _opcode,
      cmdSeq,
      buf
    );
  }
  else {
    printf("Test Command Output port not connected!\n");
  }
}

void PassiveTestTesterBase ::
  sendCmd_CMD_ENUM(
      const NATIVE_INT_TYPE instance,
      U32 cmdSeq,
      FormalParamEnum en
  )
{
  // Serialize arguments
  Fw::CmdArgBuffer buf;
  Fw::SerializeStatus _status;

  _status = buf.serialize(en);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Call output command port
  FwOpcodeType _opcode;
  const U32 idBase = this->getIdBase();
  _opcode = PassiveTestComponentBase::OPCODE_CMD_ENUM + idBase;

  if (this->m_to_cmdIn[0].isConnected()) {
    this->m_to_cmdIn[0].invoke(
      _opcode,
      cmdSeq,
      buf
    );
  }
  else {
    printf("Test Command Output port not connected!\n");
  }
}

void PassiveTestTesterBase ::
  sendCmd_CMD_ARRAY(
      const NATIVE_INT_TYPE instance,
      U32 cmdSeq,
      FormalParamArray arr
  )
{
  // Serialize arguments
  Fw::CmdArgBuffer buf;
  Fw::SerializeStatus _status;

  _status = buf.serialize(arr);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Call output command port
  FwOpcodeType _opcode;
  const U32 idBase = this->getIdBase();
  _opcode = PassiveTestComponentBase::OPCODE_CMD_ARRAY + idBase;

  if (this->m_to_cmdIn[0].isConnected()) {
    this->m_to_cmdIn[0].invoke(
      _opcode,
      cmdSeq,
      buf
    );
  }
  else {
    printf("Test Command Output port not connected!\n");
  }
}

void PassiveTestTesterBase ::
  sendCmd_CMD_STRUCT(
      const NATIVE_INT_TYPE instance,
      U32 cmdSeq,
      FormalParamStruct str
  )
{
  // Serialize arguments
  Fw::CmdArgBuffer buf;
  Fw::SerializeStatus _status;

  _status = buf.serialize(str);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Call output command port
  FwOpcodeType _opcode;
  const U32 idBase = this->getIdBase();
  _opcode = PassiveTestComponentBase::OPCODE_CMD_STRUCT + idBase;

  if (this->m_to_cmdIn[0].isConnected()) {
    this->m_to_cmdIn[0].invoke(
      _opcode,
      cmdSeq,
      buf
    );
  }
  else {
    printf("Test Command Output port not connected!\n");
  }
}

// ----------------------------------------------------------------------
// Functions for testing events
// ----------------------------------------------------------------------

void PassiveTestTesterBase ::
  dispatchEvents(
      FwEventIdType id,
      Fw::Time& timeTag,
      const Fw::LogSeverity severity,
      Fw::LogBuffer& args
  )
{
  args.resetDeser();

  const U32 idBase = this->getIdBase();
  FW_ASSERT(id >= idBase, id, idBase);

  switch (id - idBase) {
    case PassiveTestComponentBase::EVENTID_EVENTNOARGS: {
#if FW_AMPCS_COMPATIBLE
      // For AMPCS, decode zero arguments
      Fw::SerializeStatus _zero_status = Fw::FW_SERIALIZE_OK;
      U8 _noArgs;
      _zero_status = args.deserialize(_noArgs);
      FW_ASSERT(
        _zero_status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_zero_status)
      );
#endif
      this->logIn_ACTIVITY_HI_EventNoArgs();
      break;
    }

    case PassiveTestComponentBase::EVENTID_EVENTPRIMITIVE: {
      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
      // Deserialize the number of arguments.
      U8 _numArgs;
      _status = args.deserialize(_numArgs);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
      // Verify they match expected.
      FW_ASSERT(_numArgs == 6, _numArgs, 6);
#endif

      U32 u32_1;
#if FW_AMPCS_COMPATIBLE
      {
        // Deserialize the argument size
        U8 _argSize;
        _status = args.deserialize(_argSize);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        FW_ASSERT(_argSize == sizeof(U32), _argSize, sizeof(U32));
      }
#endif
      _status = args.deserialize(u32_1);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

      U32 u32_2;
#if FW_AMPCS_COMPATIBLE
      {
        // Deserialize the argument size
        U8 _argSize;
        _status = args.deserialize(_argSize);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        FW_ASSERT(_argSize == sizeof(U32), _argSize, sizeof(U32));
      }
#endif
      _status = args.deserialize(u32_2);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

      F32 f32_1;
#if FW_AMPCS_COMPATIBLE
      {
        // Deserialize the argument size
        U8 _argSize;
        _status = args.deserialize(_argSize);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        FW_ASSERT(_argSize == sizeof(F32), _argSize, sizeof(F32));
      }
#endif
      _status = args.deserialize(f32_1);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

      F32 f32_2;
#if FW_AMPCS_COMPATIBLE
      {
        // Deserialize the argument size
        U8 _argSize;
        _status = args.deserialize(_argSize);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        FW_ASSERT(_argSize == sizeof(F32), _argSize, sizeof(F32));
      }
#endif
      _status = args.deserialize(f32_2);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

      bool b1;
#if FW_AMPCS_COMPATIBLE
      {
        // Deserialize the argument size
        U8 _argSize;
        _status = args.deserialize(_argSize);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        FW_ASSERT(_argSize == sizeof(U8), _argSize, sizeof(U8));
      }
#endif
      _status = args.deserialize(b1);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

      bool b2;
#if FW_AMPCS_COMPATIBLE
      {
        // Deserialize the argument size
        U8 _argSize;
        _status = args.deserialize(_argSize);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        FW_ASSERT(_argSize == sizeof(U8), _argSize, sizeof(U8));
      }
#endif
      _status = args.deserialize(b2);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
      this->logIn_ACTIVITY_LO_EventPrimitive(u32_1, u32_2, f32_1, f32_2, b1, b2);
      break;
    }

    case PassiveTestComponentBase::EVENTID_EVENTSTRING: {
      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
      // Deserialize the number of arguments.
      U8 _numArgs;
      _status = args.deserialize(_numArgs);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
      // Verify they match expected.
      FW_ASSERT(_numArgs == 2, _numArgs, 2);
#endif

      Fw::LogStringArg str1;
#if FW_AMPCS_COMPATIBLE
      {
        // Deserialize the argument size
        U8 _argSize;
        _status = args.deserialize(_argSize);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        FW_ASSERT(_argSize == Fw::LogStringArg::SERIALIZED_SIZE, _argSize, Fw::LogStringArg::SERIALIZED_SIZE);
      }
#endif
      _status = args.deserialize(str1);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

      Fw::LogStringArg str2;
#if FW_AMPCS_COMPATIBLE
      {
        // Deserialize the argument size
        U8 _argSize;
        _status = args.deserialize(_argSize);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        FW_ASSERT(_argSize == Fw::LogStringArg::SERIALIZED_SIZE, _argSize, Fw::LogStringArg::SERIALIZED_SIZE);
      }
#endif
      _status = args.deserialize(str2);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
      this->logIn_COMMAND_EventString(str1, str2);
      break;
    }

    case PassiveTestComponentBase::EVENTID_EVENTENUM: {
      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
      // Deserialize the number of arguments.
      U8 _numArgs;
      _status = args.deserialize(_numArgs);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
      // Verify they match expected.
      FW_ASSERT(_numArgs == 1, _numArgs, 1);
#endif

      FormalParamEnum en;
#if FW_AMPCS_COMPATIBLE
      {
        // Deserialize the argument size
        U8 _argSize;
        _status = args.deserialize(_argSize);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        FW_ASSERT(_argSize == FormalParamEnum::SERIALIZED_SIZE, _argSize, FormalParamEnum::SERIALIZED_SIZE);
      }
#endif
      _status = args.deserialize(en);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
      this->logIn_DIAGNOSTIC_EventEnum(en);
      break;
    }

    case PassiveTestComponentBase::EVENTID_EVENTARRAY: {
      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
      // Deserialize the number of arguments.
      U8 _numArgs;
      _status = args.deserialize(_numArgs);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
      // Verify they match expected.
      FW_ASSERT(_numArgs == 1 + 1, _numArgs, 1 + 1);

      // For FATAL, there is a stack size of 4 and a dummy entry
      U8 stackArgLen;
      _status = args.deserialize(stackArgLen);
      FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
      );
      FW_ASSERT(stackArgLen == 4, stackArgLen);

      U32 dummyStackArg;
      _status = args.deserialize(dummyStackArg);
      FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
      );
      FW_ASSERT(dummyStackArg == 0, dummyStackArg);
#endif

      FormalParamArray arr;
#if FW_AMPCS_COMPATIBLE
      {
        // Deserialize the argument size
        U8 _argSize;
        _status = args.deserialize(_argSize);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        FW_ASSERT(_argSize == FormalParamArray::SERIALIZED_SIZE, _argSize, FormalParamArray::SERIALIZED_SIZE);
      }
#endif
      _status = args.deserialize(arr);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
      this->logIn_FATAL_EventArray(arr);
      break;
    }

    case PassiveTestComponentBase::EVENTID_EVENTSTRUCT: {
      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
      // Deserialize the number of arguments.
      U8 _numArgs;
      _status = args.deserialize(_numArgs);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
      // Verify they match expected.
      FW_ASSERT(_numArgs == 1, _numArgs, 1);
#endif

      FormalParamStruct str;
#if FW_AMPCS_COMPATIBLE
      {
        // Deserialize the argument size
        U8 _argSize;
        _status = args.deserialize(_argSize);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        FW_ASSERT(_argSize == FormalParamStruct::SERIALIZED_SIZE, _argSize, FormalParamStruct::SERIALIZED_SIZE);
      }
#endif
      _status = args.deserialize(str);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
      this->logIn_WARNING_HI_EventStruct(str);
      break;
    }

    case PassiveTestComponentBase::EVENTID_EVENTBOOL: {
      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
      // Deserialize the number of arguments.
      U8 _numArgs;
      _status = args.deserialize(_numArgs);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
      // Verify they match expected.
      FW_ASSERT(_numArgs == 1, _numArgs, 1);
#endif

      bool b;
#if FW_AMPCS_COMPATIBLE
      {
        // Deserialize the argument size
        U8 _argSize;
        _status = args.deserialize(_argSize);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        FW_ASSERT(_argSize == sizeof(U8), _argSize, sizeof(U8));
      }
#endif
      _status = args.deserialize(b);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
      this->logIn_WARNING_LO_EventBool(b);
      break;
    }

    default: {
      FW_ASSERT(0, id);
      break;
    }
  }
}

#if FW_ENABLE_TEXT_LOGGING

void PassiveTestTesterBase ::
  textLogIn(
      FwEventIdType id,
      Fw::Time& timeTag,
      const Fw::LogSeverity severity,
      const Fw::TextLogString& text
  )
{
  TextLogEntry e = { id, timeTag, severity, text };
  textLogHistory->push_back(e);
}

#endif

void PassiveTestTesterBase ::
  logIn_ACTIVITY_HI_EventNoArgs()
{
  this->eventsSize_EventNoArgs++;
  this->eventsSize++;
}

void PassiveTestTesterBase ::
  logIn_ACTIVITY_LO_EventPrimitive(
      U32 u32_1,
      U32 u32_2,
      F32 f32_1,
      F32 f32_2,
      bool b1,
      bool b2
  )
{
  EventEntry_EventPrimitive _e = {
    u32_1,
    u32_2,
    f32_1,
    f32_2,
    b1,
    b2
  };
  eventHistory_EventPrimitive->push_back(_e);
  this->eventsSize++;
}

void PassiveTestTesterBase ::
  logIn_COMMAND_EventString(
      const Fw::LogStringArg& str1,
      const Fw::LogStringArg& str2
  )
{
  EventEntry_EventString _e = {
    str1,
    str2
  };
  eventHistory_EventString->push_back(_e);
  this->eventsSize++;
}

void PassiveTestTesterBase ::
  logIn_DIAGNOSTIC_EventEnum(FormalParamEnum en)
{
  EventEntry_EventEnum _e = {
    en
  };
  eventHistory_EventEnum->push_back(_e);
  this->eventsSize++;
}

void PassiveTestTesterBase ::
  logIn_FATAL_EventArray(FormalParamArray arr)
{
  EventEntry_EventArray _e = {
    arr
  };
  eventHistory_EventArray->push_back(_e);
  this->eventsSize++;
}

void PassiveTestTesterBase ::
  logIn_WARNING_HI_EventStruct(FormalParamStruct str)
{
  EventEntry_EventStruct _e = {
    str
  };
  eventHistory_EventStruct->push_back(_e);
  this->eventsSize++;
}

void PassiveTestTesterBase ::
  logIn_WARNING_LO_EventBool(bool b)
{
  EventEntry_EventBool _e = {
    b
  };
  eventHistory_EventBool->push_back(_e);
  this->eventsSize++;
}

// ----------------------------------------------------------------------
// Functions for testing telemetry
// ----------------------------------------------------------------------

void PassiveTestTesterBase ::
  dispatchTlm(
      FwChanIdType id,
      Fw::Time& timeTag,
      Fw::TlmBuffer& val
  )
{
  val.resetDeser();

  const U32 idBase = this->getIdBase();
  FW_ASSERT(id >= idBase, id, idBase);

  switch (id - idBase) {
    case PassiveTestComponentBase::CHANNELID_CHANNELENUM: {
      FormalParamEnum arg;
      const Fw::SerializeStatus _status = val.deserialize(arg);

      if (_status != Fw::FW_SERIALIZE_OK) {
        printf("Error deserializing ChannelEnum: %d\n", _status);
        return;
      }

      this->tlmInput_ChannelEnum(timeTag, arg);
      break;
    }

    case PassiveTestComponentBase::CHANNELID_CHANNELARRAY: {
      FormalParamArray arg;
      const Fw::SerializeStatus _status = val.deserialize(arg);

      if (_status != Fw::FW_SERIALIZE_OK) {
        printf("Error deserializing ChannelArray: %d\n", _status);
        return;
      }

      this->tlmInput_ChannelArray(timeTag, arg);
      break;
    }

    case PassiveTestComponentBase::CHANNELID_CHANNELSTRUCT: {
      FormalParamStruct arg;
      const Fw::SerializeStatus _status = val.deserialize(arg);

      if (_status != Fw::FW_SERIALIZE_OK) {
        printf("Error deserializing ChannelStruct: %d\n", _status);
        return;
      }

      this->tlmInput_ChannelStruct(timeTag, arg);
      break;
    }

    case PassiveTestComponentBase::CHANNELID_CHANNELU32: {
      U32 arg;
      const Fw::SerializeStatus _status = val.deserialize(arg);

      if (_status != Fw::FW_SERIALIZE_OK) {
        printf("Error deserializing ChannelU32: %d\n", _status);
        return;
      }

      this->tlmInput_ChannelU32(timeTag, arg);
      break;
    }

    case PassiveTestComponentBase::CHANNELID_CHANNELF32: {
      F32 arg;
      const Fw::SerializeStatus _status = val.deserialize(arg);

      if (_status != Fw::FW_SERIALIZE_OK) {
        printf("Error deserializing ChannelF32: %d\n", _status);
        return;
      }

      this->tlmInput_ChannelF32(timeTag, arg);
      break;
    }

    case PassiveTestComponentBase::CHANNELID_CHANNELSTRING: {
      Fw::TlmString arg;
      const Fw::SerializeStatus _status = val.deserialize(arg);

      if (_status != Fw::FW_SERIALIZE_OK) {
        printf("Error deserializing ChannelString: %d\n", _status);
        return;
      }

      this->tlmInput_ChannelString(timeTag, arg);
      break;
    }

    default: {
      FW_ASSERT(0, id);
      break;
    }
  }
}

void PassiveTestTesterBase ::
  tlmInput_ChannelEnum(
      Fw::Time& timeTag,
      const FormalParamEnum& val
  )
{
  TlmEntry_ChannelEnum e = { timeTag, val };
  this->tlmHistory_ChannelEnum->push_back(e);
  this->tlmSize++;
}

void PassiveTestTesterBase ::
  tlmInput_ChannelArray(
      Fw::Time& timeTag,
      const FormalParamArray& val
  )
{
  TlmEntry_ChannelArray e = { timeTag, val };
  this->tlmHistory_ChannelArray->push_back(e);
  this->tlmSize++;
}

void PassiveTestTesterBase ::
  tlmInput_ChannelStruct(
      Fw::Time& timeTag,
      const FormalParamStruct& val
  )
{
  TlmEntry_ChannelStruct e = { timeTag, val };
  this->tlmHistory_ChannelStruct->push_back(e);
  this->tlmSize++;
}

void PassiveTestTesterBase ::
  tlmInput_ChannelU32(
      Fw::Time& timeTag,
      const U32& val
  )
{
  TlmEntry_ChannelU32 e = { timeTag, val };
  this->tlmHistory_ChannelU32->push_back(e);
  this->tlmSize++;
}

void PassiveTestTesterBase ::
  tlmInput_ChannelF32(
      Fw::Time& timeTag,
      const F32& val
  )
{
  TlmEntry_ChannelF32 e = { timeTag, val };
  this->tlmHistory_ChannelF32->push_back(e);
  this->tlmSize++;
}

void PassiveTestTesterBase ::
  tlmInput_ChannelString(
      const Fw::Time& timeTag,
      const Fw::TlmString& val
  )
{
  TlmEntry_ChannelString e = { timeTag, val };
  this->tlmHistory_ChannelString->push_back(e);
  this->tlmSize++;
}

// ----------------------------------------------------------------------
// Functions to test parameters
// ----------------------------------------------------------------------

void PassiveTestTesterBase ::
  paramSet_ParamBool(
      const bool& val,
      Fw::ParamValid valid
  )
{
  this->m_param_ParamBool = val;
  this->m_param_ParamBool_valid = valid;
}

void PassiveTestTesterBase ::
  paramSend_ParamBool(
      NATIVE_INT_TYPE instance,
      U32 cmdSeq
  )
{
  // Build command for parameter set
  Fw::CmdArgBuffer args;
  FW_ASSERT(
    args.serialize(this->m_param_ParamBool) == Fw::FW_SERIALIZE_OK
  );

  const U32 idBase = this->getIdBase();
  FwOpcodeType _prmOpcode =  PassiveTestComponentBase::OPCODE_PARAMBOOL_SET + idBase;

  if (not this->m_to_cmdIn[0].isConnected()) {
    printf("Test Command Output port not connected!\n");
  }
  else {
    this->m_to_cmdIn[0].invoke(
      _prmOpcode,
      cmdSeq,
      args
    );
  }
}

void PassiveTestTesterBase ::
  paramSave_ParamBool(
      NATIVE_INT_TYPE instance,
      U32 cmdSeq
  )
{
  Fw::CmdArgBuffer args;
  const U32 idBase = this->getIdBase();
  FwOpcodeType _prmOpcode = PassiveTestComponentBase::OPCODE_PARAMBOOL_SAVE + idBase;

  if (not this->m_to_cmdIn[0].isConnected()) {
    printf("Test Command Output port not connected!\n");
  }
  else {
    this->m_to_cmdIn[0].invoke(
      _prmOpcode,
      cmdSeq,
      args
    );
  }
}

void PassiveTestTesterBase ::
  paramSet_ParamU32(
      const U32& val,
      Fw::ParamValid valid
  )
{
  this->m_param_ParamU32 = val;
  this->m_param_ParamU32_valid = valid;
}

void PassiveTestTesterBase ::
  paramSend_ParamU32(
      NATIVE_INT_TYPE instance,
      U32 cmdSeq
  )
{
  // Build command for parameter set
  Fw::CmdArgBuffer args;
  FW_ASSERT(
    args.serialize(this->m_param_ParamU32) == Fw::FW_SERIALIZE_OK
  );

  const U32 idBase = this->getIdBase();
  FwOpcodeType _prmOpcode =  PassiveTestComponentBase::OPCODE_PARAMU32_SET + idBase;

  if (not this->m_to_cmdIn[0].isConnected()) {
    printf("Test Command Output port not connected!\n");
  }
  else {
    this->m_to_cmdIn[0].invoke(
      _prmOpcode,
      cmdSeq,
      args
    );
  }
}

void PassiveTestTesterBase ::
  paramSave_ParamU32(
      NATIVE_INT_TYPE instance,
      U32 cmdSeq
  )
{
  Fw::CmdArgBuffer args;
  const U32 idBase = this->getIdBase();
  FwOpcodeType _prmOpcode = PassiveTestComponentBase::OPCODE_PARAMU32_SAVE + idBase;

  if (not this->m_to_cmdIn[0].isConnected()) {
    printf("Test Command Output port not connected!\n");
  }
  else {
    this->m_to_cmdIn[0].invoke(
      _prmOpcode,
      cmdSeq,
      args
    );
  }
}

void PassiveTestTesterBase ::
  paramSet_ParamString(
      const Fw::ParamString& val,
      Fw::ParamValid valid
  )
{
  this->m_param_ParamString = val;
  this->m_param_ParamString_valid = valid;
}

void PassiveTestTesterBase ::
  paramSend_ParamString(
      NATIVE_INT_TYPE instance,
      U32 cmdSeq
  )
{
  // Build command for parameter set
  Fw::CmdArgBuffer args;
  FW_ASSERT(
    args.serialize(this->m_param_ParamString) == Fw::FW_SERIALIZE_OK
  );

  const U32 idBase = this->getIdBase();
  FwOpcodeType _prmOpcode =  PassiveTestComponentBase::OPCODE_PARAMSTRING_SET + idBase;

  if (not this->m_to_cmdIn[0].isConnected()) {
    printf("Test Command Output port not connected!\n");
  }
  else {
    this->m_to_cmdIn[0].invoke(
      _prmOpcode,
      cmdSeq,
      args
    );
  }
}

void PassiveTestTesterBase ::
  paramSave_ParamString(
      NATIVE_INT_TYPE instance,
      U32 cmdSeq
  )
{
  Fw::CmdArgBuffer args;
  const U32 idBase = this->getIdBase();
  FwOpcodeType _prmOpcode = PassiveTestComponentBase::OPCODE_PARAMSTRING_SAVE + idBase;

  if (not this->m_to_cmdIn[0].isConnected()) {
    printf("Test Command Output port not connected!\n");
  }
  else {
    this->m_to_cmdIn[0].invoke(
      _prmOpcode,
      cmdSeq,
      args
    );
  }
}

void PassiveTestTesterBase ::
  paramSet_ParamEnum(
      const FormalParamEnum& val,
      Fw::ParamValid valid
  )
{
  this->m_param_ParamEnum = val;
  this->m_param_ParamEnum_valid = valid;
}

void PassiveTestTesterBase ::
  paramSend_ParamEnum(
      NATIVE_INT_TYPE instance,
      U32 cmdSeq
  )
{
  // Build command for parameter set
  Fw::CmdArgBuffer args;
  FW_ASSERT(
    args.serialize(this->m_param_ParamEnum) == Fw::FW_SERIALIZE_OK
  );

  const U32 idBase = this->getIdBase();
  FwOpcodeType _prmOpcode =  PassiveTestComponentBase::OPCODE_PARAMENUM_SET + idBase;

  if (not this->m_to_cmdIn[0].isConnected()) {
    printf("Test Command Output port not connected!\n");
  }
  else {
    this->m_to_cmdIn[0].invoke(
      _prmOpcode,
      cmdSeq,
      args
    );
  }
}

void PassiveTestTesterBase ::
  paramSave_ParamEnum(
      NATIVE_INT_TYPE instance,
      U32 cmdSeq
  )
{
  Fw::CmdArgBuffer args;
  const U32 idBase = this->getIdBase();
  FwOpcodeType _prmOpcode = PassiveTestComponentBase::OPCODE_PARAMENUM_SAVE + idBase;

  if (not this->m_to_cmdIn[0].isConnected()) {
    printf("Test Command Output port not connected!\n");
  }
  else {
    this->m_to_cmdIn[0].invoke(
      _prmOpcode,
      cmdSeq,
      args
    );
  }
}

void PassiveTestTesterBase ::
  paramSet_ParamArray(
      const FormalParamArray& val,
      Fw::ParamValid valid
  )
{
  this->m_param_ParamArray = val;
  this->m_param_ParamArray_valid = valid;
}

void PassiveTestTesterBase ::
  paramSend_ParamArray(
      NATIVE_INT_TYPE instance,
      U32 cmdSeq
  )
{
  // Build command for parameter set
  Fw::CmdArgBuffer args;
  FW_ASSERT(
    args.serialize(this->m_param_ParamArray) == Fw::FW_SERIALIZE_OK
  );

  const U32 idBase = this->getIdBase();
  FwOpcodeType _prmOpcode =  PassiveTestComponentBase::OPCODE_PARAMARRAY_SET + idBase;

  if (not this->m_to_cmdIn[0].isConnected()) {
    printf("Test Command Output port not connected!\n");
  }
  else {
    this->m_to_cmdIn[0].invoke(
      _prmOpcode,
      cmdSeq,
      args
    );
  }
}

void PassiveTestTesterBase ::
  paramSave_ParamArray(
      NATIVE_INT_TYPE instance,
      U32 cmdSeq
  )
{
  Fw::CmdArgBuffer args;
  const U32 idBase = this->getIdBase();
  FwOpcodeType _prmOpcode = PassiveTestComponentBase::OPCODE_PARAMARRAY_SAVE + idBase;

  if (not this->m_to_cmdIn[0].isConnected()) {
    printf("Test Command Output port not connected!\n");
  }
  else {
    this->m_to_cmdIn[0].invoke(
      _prmOpcode,
      cmdSeq,
      args
    );
  }
}

void PassiveTestTesterBase ::
  paramSet_ParamStruct(
      const FormalParamStruct& val,
      Fw::ParamValid valid
  )
{
  this->m_param_ParamStruct = val;
  this->m_param_ParamStruct_valid = valid;
}

void PassiveTestTesterBase ::
  paramSend_ParamStruct(
      NATIVE_INT_TYPE instance,
      U32 cmdSeq
  )
{
  // Build command for parameter set
  Fw::CmdArgBuffer args;
  FW_ASSERT(
    args.serialize(this->m_param_ParamStruct) == Fw::FW_SERIALIZE_OK
  );

  const U32 idBase = this->getIdBase();
  FwOpcodeType _prmOpcode =  PassiveTestComponentBase::OPCODE_PARAMSTRUCT_SET + idBase;

  if (not this->m_to_cmdIn[0].isConnected()) {
    printf("Test Command Output port not connected!\n");
  }
  else {
    this->m_to_cmdIn[0].invoke(
      _prmOpcode,
      cmdSeq,
      args
    );
  }
}

void PassiveTestTesterBase ::
  paramSave_ParamStruct(
      NATIVE_INT_TYPE instance,
      U32 cmdSeq
  )
{
  Fw::CmdArgBuffer args;
  const U32 idBase = this->getIdBase();
  FwOpcodeType _prmOpcode = PassiveTestComponentBase::OPCODE_PARAMSTRUCT_SAVE + idBase;

  if (not this->m_to_cmdIn[0].isConnected()) {
    printf("Test Command Output port not connected!\n");
  }
  else {
    this->m_to_cmdIn[0].invoke(
      _prmOpcode,
      cmdSeq,
      args
    );
  }
}

// ----------------------------------------------------------------------
// Functions to test time
// ----------------------------------------------------------------------

void PassiveTestTesterBase ::
  setTestTime(Fw::Time& timeTag)
{
  this->m_testTime = timeTag;
}

// ----------------------------------------------------------------------
// History functions
// ----------------------------------------------------------------------

void PassiveTestTesterBase ::
  clearHistory()
{
  this->clearFromPortHistory();
  this->cmdResponseHistory->clear();
#if FW_ENABLE_TEXT_LOGGING
  this->textLogHistory->clear();
#endif
  this->clearEvents();
  this->clearTlm();
}

void PassiveTestTesterBase ::
  clearFromPortHistory()
{
  this->fromPortHistorySize = 0;
  this->fromPortHistory_arrayArgsOut->clear();
  this->fromPortHistory_arrayReturnOut->clear();
  this->fromPortHistory_enumArgsOut->clear();
  this->fromPortHistory_enumReturnOut->clear();
  this->fromPortHistorySize_noArgsOut = 0;
  this->fromPortHistorySize_noArgsReturnOut = 0;
  this->fromPortHistory_primitiveArgsOut->clear();
  this->fromPortHistory_primitiveReturnOut->clear();
  this->fromPortHistory_prmGetIn->clear();
  this->fromPortHistory_prmSetIn->clear();
  this->fromPortHistory_stringArgsOut->clear();
  this->fromPortHistory_structArgsOut->clear();
  this->fromPortHistory_structReturnOut->clear();
}

void PassiveTestTesterBase ::
  pushFromPortEntry_arrayArgsOut(
      const FormalParamArray& a,
      FormalParamArray& aRef
  )
{
  FromPortEntry_arrayArgsOut _e = {
    a,
    aRef
  };
  this->fromPortHistory_arrayArgsOut->push_back(_e);
  this->fromPortHistorySize++;
}

void PassiveTestTesterBase ::
  pushFromPortEntry_arrayReturnOut(
      const FormalParamArray& a,
      FormalParamArray& aRef
  )
{
  FromPortEntry_arrayReturnOut _e = {
    a,
    aRef
  };
  this->fromPortHistory_arrayReturnOut->push_back(_e);
  this->fromPortHistorySize++;
}

void PassiveTestTesterBase ::
  pushFromPortEntry_enumArgsOut(
      const FormalParamEnum& en,
      FormalParamEnum& enRef
  )
{
  FromPortEntry_enumArgsOut _e = {
    en,
    enRef
  };
  this->fromPortHistory_enumArgsOut->push_back(_e);
  this->fromPortHistorySize++;
}

void PassiveTestTesterBase ::
  pushFromPortEntry_enumReturnOut(
      const FormalParamEnum& en,
      FormalParamEnum& enRef
  )
{
  FromPortEntry_enumReturnOut _e = {
    en,
    enRef
  };
  this->fromPortHistory_enumReturnOut->push_back(_e);
  this->fromPortHistorySize++;
}

void PassiveTestTesterBase ::
  pushFromPortEntry_noArgsOut()
{
  this->fromPortHistorySize_noArgsOut++;
  this->fromPortHistorySize++;
}

void PassiveTestTesterBase ::
  pushFromPortEntry_noArgsReturnOut()
{
  this->fromPortHistorySize_noArgsReturnOut++;
  this->fromPortHistorySize++;
}

void PassiveTestTesterBase ::
  pushFromPortEntry_primitiveArgsOut(
      U32 u32,
      U32& u32Ref,
      F32 f32,
      F32& f32Ref,
      bool b,
      bool& bRef
  )
{
  FromPortEntry_primitiveArgsOut _e = {
    u32,
    u32Ref,
    f32,
    f32Ref,
    b,
    bRef
  };
  this->fromPortHistory_primitiveArgsOut->push_back(_e);
  this->fromPortHistorySize++;
}

void PassiveTestTesterBase ::
  pushFromPortEntry_primitiveReturnOut(
      U32 u32,
      U32& u32Ref,
      F32 f32,
      F32& f32Ref,
      bool b,
      bool& bRef
  )
{
  FromPortEntry_primitiveReturnOut _e = {
    u32,
    u32Ref,
    f32,
    f32Ref,
    b,
    bRef
  };
  this->fromPortHistory_primitiveReturnOut->push_back(_e);
  this->fromPortHistorySize++;
}

void PassiveTestTesterBase ::
  pushFromPortEntry_prmGetIn(
      FwPrmIdType id,
      Fw::ParamBuffer& val
  )
{
  FromPortEntry_prmGetIn _e = {
    id,
    val
  };
  this->fromPortHistory_prmGetIn->push_back(_e);
  this->fromPortHistorySize++;
}

void PassiveTestTesterBase ::
  pushFromPortEntry_prmSetIn(
      FwPrmIdType id,
      Fw::ParamBuffer& val
  )
{
  FromPortEntry_prmSetIn _e = {
    id,
    val
  };
  this->fromPortHistory_prmSetIn->push_back(_e);
  this->fromPortHistorySize++;
}

void PassiveTestTesterBase ::
  pushFromPortEntry_stringArgsOut(
      const StringArgsPortStrings::StringSize80& str80,
      StringArgsPortStrings::StringSize80& str80Ref,
      const StringArgsPortStrings::StringSize100& str100,
      StringArgsPortStrings::StringSize100& str100Ref
  )
{
  FromPortEntry_stringArgsOut _e = {
    str80,
    str80Ref,
    str100,
    str100Ref
  };
  this->fromPortHistory_stringArgsOut->push_back(_e);
  this->fromPortHistorySize++;
}

void PassiveTestTesterBase ::
  pushFromPortEntry_structArgsOut(
      const FormalParamStruct& s,
      FormalParamStruct& sRef
  )
{
  FromPortEntry_structArgsOut _e = {
    s,
    sRef
  };
  this->fromPortHistory_structArgsOut->push_back(_e);
  this->fromPortHistorySize++;
}

void PassiveTestTesterBase ::
  pushFromPortEntry_structReturnOut(
      const FormalParamStruct& s,
      FormalParamStruct& sRef
  )
{
  FromPortEntry_structReturnOut _e = {
    s,
    sRef
  };
  this->fromPortHistory_structReturnOut->push_back(_e);
  this->fromPortHistorySize++;
}

void PassiveTestTesterBase ::
  clearEvents()
{
  this->eventsSize = 0;
  this->eventsSize_EventNoArgs = 0;
  this->eventHistory_EventPrimitive->clear();
  this->eventHistory_EventString->clear();
  this->eventHistory_EventEnum->clear();
  this->eventHistory_EventArray->clear();
  this->eventHistory_EventStruct->clear();
  this->eventHistory_EventBool->clear();
}

#if FW_ENABLE_TEXT_LOGGING

void PassiveTestTesterBase ::
  printTextLogHistoryEntry(
      const TextLogEntry& e,
      FILE* file
  )
{
  const char* severityString = "UNKNOWN";

  switch (e.severity.e) {
    case Fw::LogSeverity::FATAL:
      severityString = "FATAL";
      break;
    case Fw::LogSeverity::WARNING_HI:
      severityString = "WARNING_HI";
      break;
    case Fw::LogSeverity::WARNING_LO:
      severityString = "WARNING_LO";
      break;
    case Fw::LogSeverity::COMMAND:
      severityString = "COMMAND";
      break;
    case Fw::LogSeverity::ACTIVITY_HI:
      severityString = "ACTIVITY_HI";
      break;
    case Fw::LogSeverity::ACTIVITY_LO:
      severityString = "ACTIVITY_LO";
      break;
    case Fw::LogSeverity::DIAGNOSTIC:
     severityString = "DIAGNOSTIC";
      break;
    default:
      severityString = "SEVERITY ERROR";
      break;
  }

  fprintf(
    file,
    "EVENT: (%" PRI_FwEventIdType ") (%" PRI_FwTimeBaseStoreType ":%" PRIu32 ",%" PRIu32 ") %s: %s\n",
    e.id,
    static_cast<FwTimeBaseStoreType>(e.timeTag.getTimeBase()),
    e.timeTag.getSeconds(),
    e.timeTag.getUSeconds(),
    severityString,
    e.text.toChar()
  );
}

void PassiveTestTesterBase ::
  printTextLogHistory(FILE* const file)
{
  for (U32 i = 0; i < this->textLogHistory->size(); i++) {
    this->printTextLogHistoryEntry(
      this->textLogHistory->at(i),
      file
    );
  }
}

#endif

void PassiveTestTesterBase ::
  clearTlm()
{
  this->tlmSize = 0;
  this->tlmHistory_ChannelEnum->clear();
  this->tlmHistory_ChannelArray->clear();
  this->tlmHistory_ChannelStruct->clear();
  this->tlmHistory_ChannelU32->clear();
  this->tlmHistory_ChannelF32->clear();
  this->tlmHistory_ChannelString->clear();
}

// ----------------------------------------------------------------------
// Static functions for output ports
// ----------------------------------------------------------------------

void PassiveTestTesterBase ::
  from_cmdRegOut_static(
      Fw::PassiveComponentBase* const callComp,
      NATIVE_INT_TYPE portNum,
      FwOpcodeType opCode
  )
{

}

void PassiveTestTesterBase ::
  from_cmdResponseOut_static(
      Fw::PassiveComponentBase* const callComp,
      NATIVE_INT_TYPE portNum,
      FwOpcodeType opCode,
      U32 cmdSeq,
      const Fw::CmdResponse& response
  )
{
  PassiveTestTesterBase* _testerBase = static_cast<PassiveTestTesterBase*>(callComp);
  _testerBase->cmdResponseIn(opCode, cmdSeq, response);
}

void PassiveTestTesterBase ::
  from_eventOut_static(
      Fw::PassiveComponentBase* const callComp,
      NATIVE_INT_TYPE portNum,
      FwEventIdType id,
      Fw::Time& timeTag,
      const Fw::LogSeverity& severity,
      Fw::LogBuffer& args
  )
{
  PassiveTestTesterBase* _testerBase = static_cast<PassiveTestTesterBase*>(callComp);
  _testerBase->dispatchEvents(id, timeTag, severity, args);
}

Fw::ParamValid PassiveTestTesterBase ::
  from_prmGetOut_static(
      Fw::PassiveComponentBase* const callComp,
      NATIVE_INT_TYPE portNum,
      FwPrmIdType id,
      Fw::ParamBuffer& val
  )
{
  PassiveTestTesterBase* _testerBase = static_cast<PassiveTestTesterBase*>(callComp);

  Fw::SerializeStatus _status;

  Fw::ParamValid _ret = Fw::ParamValid::VALID;
  val.resetSer();

  const U32 idBase = _testerBase->getIdBase();
  FW_ASSERT(id >= idBase, id, idBase);

  switch (id - idBase) {
    case PassiveTestComponentBase::PARAMID_PARAMBOOL: {
      _status = val.serialize(_testerBase->m_param_ParamBool);
      _ret = _testerBase->m_param_ParamBool_valid;
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
      break;
    };

    case PassiveTestComponentBase::PARAMID_PARAMU32: {
      _status = val.serialize(_testerBase->m_param_ParamU32);
      _ret = _testerBase->m_param_ParamU32_valid;
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
      break;
    };

    case PassiveTestComponentBase::PARAMID_PARAMSTRING: {
      _status = val.serialize(_testerBase->m_param_ParamString);
      _ret = _testerBase->m_param_ParamString_valid;
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
      break;
    };

    case PassiveTestComponentBase::PARAMID_PARAMENUM: {
      _status = val.serialize(_testerBase->m_param_ParamEnum);
      _ret = _testerBase->m_param_ParamEnum_valid;
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
      break;
    };

    case PassiveTestComponentBase::PARAMID_PARAMARRAY: {
      _status = val.serialize(_testerBase->m_param_ParamArray);
      _ret = _testerBase->m_param_ParamArray_valid;
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
      break;
    };

    case PassiveTestComponentBase::PARAMID_PARAMSTRUCT: {
      _status = val.serialize(_testerBase->m_param_ParamStruct);
      _ret = _testerBase->m_param_ParamStruct_valid;
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
      break;
    };

    default:
      FW_ASSERT(0, id);
      break;
  }

  return _ret;
}

void PassiveTestTesterBase ::
  from_prmSetOut_static(
      Fw::PassiveComponentBase* const callComp,
      NATIVE_INT_TYPE portNum,
      FwPrmIdType id,
      Fw::ParamBuffer& val
  )
{
  PassiveTestTesterBase* _testerBase = static_cast<PassiveTestTesterBase*>(callComp);
  Fw::SerializeStatus _status;
  val.resetSer();

  const U32 idBase = _testerBase->getIdBase();
  FW_ASSERT(id >= idBase, id, idBase);

  switch (id - idBase) {
    case PassiveTestComponentBase::PARAMID_PARAMBOOL: {
      bool ParamBoolVal;
      _status = val.deserialize(ParamBoolVal);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
      FW_ASSERT(
        ParamBoolVal ==
        _testerBase->m_param_ParamBool
      );
      break;
    };

    case PassiveTestComponentBase::PARAMID_PARAMU32: {
      U32 ParamU32Val;
      _status = val.deserialize(ParamU32Val);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
      FW_ASSERT(
        ParamU32Val ==
        _testerBase->m_param_ParamU32
      );
      break;
    };

    case PassiveTestComponentBase::PARAMID_PARAMSTRING: {
      Fw::ParamString ParamStringVal;
      _status = val.deserialize(ParamStringVal);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
      FW_ASSERT(
        ParamStringVal ==
        _testerBase->m_param_ParamString
      );
      break;
    };

    case PassiveTestComponentBase::PARAMID_PARAMENUM: {
      FormalParamEnum ParamEnumVal;
      _status = val.deserialize(ParamEnumVal);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
      FW_ASSERT(
        ParamEnumVal ==
        _testerBase->m_param_ParamEnum
      );
      break;
    };

    case PassiveTestComponentBase::PARAMID_PARAMARRAY: {
      FormalParamArray ParamArrayVal;
      _status = val.deserialize(ParamArrayVal);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
      FW_ASSERT(
        ParamArrayVal ==
        _testerBase->m_param_ParamArray
      );
      break;
    };

    case PassiveTestComponentBase::PARAMID_PARAMSTRUCT: {
      FormalParamStruct ParamStructVal;
      _status = val.deserialize(ParamStructVal);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
      FW_ASSERT(
        ParamStructVal ==
        _testerBase->m_param_ParamStruct
      );
      break;
    };

    default:
      FW_ASSERT(0, id);
      break;
  }
}

#if FW_ENABLE_TEXT_LOGGING == 1

void PassiveTestTesterBase ::
  from_textEventOut_static(
      Fw::PassiveComponentBase* const callComp,
      NATIVE_INT_TYPE portNum,
      FwEventIdType id,
      Fw::Time& timeTag,
      const Fw::LogSeverity& severity,
      Fw::TextLogString& text
  )
{
  PassiveTestTesterBase* _testerBase = static_cast<PassiveTestTesterBase*>(callComp);
  _testerBase->textLogIn(id, timeTag, severity, text);
}

#endif

void PassiveTestTesterBase ::
  from_timeGetOut_static(
      Fw::PassiveComponentBase* const callComp,
      NATIVE_INT_TYPE portNum,
      Fw::Time& time
  )
{
  PassiveTestTesterBase* _testerBase = static_cast<PassiveTestTesterBase*>(callComp);
  time = _testerBase->m_testTime;
}

void PassiveTestTesterBase ::
  from_tlmOut_static(
      Fw::PassiveComponentBase* const callComp,
      NATIVE_INT_TYPE portNum,
      FwChanIdType id,
      Fw::Time& timeTag,
      Fw::TlmBuffer& val
  )
{
  PassiveTestTesterBase* _testerBase = static_cast<PassiveTestTesterBase*>(callComp);
  _testerBase->dispatchTlm(id, timeTag, val);
}

void PassiveTestTesterBase ::
  from_arrayArgsOut_static(
      Fw::PassiveComponentBase* const callComp,
      NATIVE_INT_TYPE portNum,
      const FormalParamArray& a,
      FormalParamArray& aRef
  )
{
  FW_ASSERT(callComp != nullptr);
  PassiveTestTesterBase* _testerBase = static_cast<PassiveTestTesterBase*>(callComp);
  _testerBase->from_arrayArgsOut_handlerBase(
    portNum,
    a,
    aRef
  );
}

FormalParamArray PassiveTestTesterBase ::
  from_arrayReturnOut_static(
      Fw::PassiveComponentBase* const callComp,
      NATIVE_INT_TYPE portNum,
      const FormalParamArray& a,
      FormalParamArray& aRef
  )
{
  FW_ASSERT(callComp != nullptr);
  PassiveTestTesterBase* _testerBase = static_cast<PassiveTestTesterBase*>(callComp);
  return _testerBase->from_arrayReturnOut_handlerBase(
    portNum,
    a,
    aRef
  );
}

void PassiveTestTesterBase ::
  from_enumArgsOut_static(
      Fw::PassiveComponentBase* const callComp,
      NATIVE_INT_TYPE portNum,
      const FormalParamEnum& en,
      FormalParamEnum& enRef
  )
{
  FW_ASSERT(callComp != nullptr);
  PassiveTestTesterBase* _testerBase = static_cast<PassiveTestTesterBase*>(callComp);
  _testerBase->from_enumArgsOut_handlerBase(
    portNum,
    en,
    enRef
  );
}

FormalParamEnum PassiveTestTesterBase ::
  from_enumReturnOut_static(
      Fw::PassiveComponentBase* const callComp,
      NATIVE_INT_TYPE portNum,
      const FormalParamEnum& en,
      FormalParamEnum& enRef
  )
{
  FW_ASSERT(callComp != nullptr);
  PassiveTestTesterBase* _testerBase = static_cast<PassiveTestTesterBase*>(callComp);
  return _testerBase->from_enumReturnOut_handlerBase(
    portNum,
    en,
    enRef
  );
}

void PassiveTestTesterBase ::
  from_noArgsOut_static(
      Fw::PassiveComponentBase* const callComp,
      NATIVE_INT_TYPE portNum
  )
{
  FW_ASSERT(callComp != nullptr);
  PassiveTestTesterBase* _testerBase = static_cast<PassiveTestTesterBase*>(callComp);
  _testerBase->from_noArgsOut_handlerBase(portNum);
}

bool PassiveTestTesterBase ::
  from_noArgsReturnOut_static(
      Fw::PassiveComponentBase* const callComp,
      NATIVE_INT_TYPE portNum
  )
{
  FW_ASSERT(callComp != nullptr);
  PassiveTestTesterBase* _testerBase = static_cast<PassiveTestTesterBase*>(callComp);
  return _testerBase->from_noArgsReturnOut_handlerBase(portNum);
}

void PassiveTestTesterBase ::
  from_primitiveArgsOut_static(
      Fw::PassiveComponentBase* const callComp,
      NATIVE_INT_TYPE portNum,
      U32 u32,
      U32& u32Ref,
      F32 f32,
      F32& f32Ref,
      bool b,
      bool& bRef
  )
{
  FW_ASSERT(callComp != nullptr);
  PassiveTestTesterBase* _testerBase = static_cast<PassiveTestTesterBase*>(callComp);
  _testerBase->from_primitiveArgsOut_handlerBase(
    portNum,
    u32,
    u32Ref,
    f32,
    f32Ref,
    b,
    bRef
  );
}

U32 PassiveTestTesterBase ::
  from_primitiveReturnOut_static(
      Fw::PassiveComponentBase* const callComp,
      NATIVE_INT_TYPE portNum,
      U32 u32,
      U32& u32Ref,
      F32 f32,
      F32& f32Ref,
      bool b,
      bool& bRef
  )
{
  FW_ASSERT(callComp != nullptr);
  PassiveTestTesterBase* _testerBase = static_cast<PassiveTestTesterBase*>(callComp);
  return _testerBase->from_primitiveReturnOut_handlerBase(
    portNum,
    u32,
    u32Ref,
    f32,
    f32Ref,
    b,
    bRef
  );
}

Fw::ParamValid PassiveTestTesterBase ::
  from_prmGetIn_static(
      Fw::PassiveComponentBase* const callComp,
      NATIVE_INT_TYPE portNum,
      FwPrmIdType id,
      Fw::ParamBuffer& val
  )
{
  FW_ASSERT(callComp != nullptr);
  PassiveTestTesterBase* _testerBase = static_cast<PassiveTestTesterBase*>(callComp);
  return _testerBase->from_prmGetIn_handlerBase(
    portNum,
    id,
    val
  );
}

void PassiveTestTesterBase ::
  from_prmSetIn_static(
      Fw::PassiveComponentBase* const callComp,
      NATIVE_INT_TYPE portNum,
      FwPrmIdType id,
      Fw::ParamBuffer& val
  )
{
  FW_ASSERT(callComp != nullptr);
  PassiveTestTesterBase* _testerBase = static_cast<PassiveTestTesterBase*>(callComp);
  _testerBase->from_prmSetIn_handlerBase(
    portNum,
    id,
    val
  );
}

void PassiveTestTesterBase ::
  from_stringArgsOut_static(
      Fw::PassiveComponentBase* const callComp,
      NATIVE_INT_TYPE portNum,
      const StringArgsPortStrings::StringSize80& str80,
      StringArgsPortStrings::StringSize80& str80Ref,
      const StringArgsPortStrings::StringSize100& str100,
      StringArgsPortStrings::StringSize100& str100Ref
  )
{
  FW_ASSERT(callComp != nullptr);
  PassiveTestTesterBase* _testerBase = static_cast<PassiveTestTesterBase*>(callComp);
  _testerBase->from_stringArgsOut_handlerBase(
    portNum,
    str80,
    str80Ref,
    str100,
    str100Ref
  );
}

void PassiveTestTesterBase ::
  from_structArgsOut_static(
      Fw::PassiveComponentBase* const callComp,
      NATIVE_INT_TYPE portNum,
      const FormalParamStruct& s,
      FormalParamStruct& sRef
  )
{
  FW_ASSERT(callComp != nullptr);
  PassiveTestTesterBase* _testerBase = static_cast<PassiveTestTesterBase*>(callComp);
  _testerBase->from_structArgsOut_handlerBase(
    portNum,
    s,
    sRef
  );
}

FormalParamStruct PassiveTestTesterBase ::
  from_structReturnOut_static(
      Fw::PassiveComponentBase* const callComp,
      NATIVE_INT_TYPE portNum,
      const FormalParamStruct& s,
      FormalParamStruct& sRef
  )
{
  FW_ASSERT(callComp != nullptr);
  PassiveTestTesterBase* _testerBase = static_cast<PassiveTestTesterBase*>(callComp);
  return _testerBase->from_structReturnOut_handlerBase(
    portNum,
    s,
    sRef
  );
}

void PassiveTestTesterBase ::
  from_serialOut_static(
      Fw::PassiveComponentBase* const callComp,
      NATIVE_INT_TYPE portNum,
      Fw::SerializeBufferBase& buffer
  )
{
  FW_ASSERT(callComp != nullptr);
  PassiveTestTesterBase* _testerBase = static_cast<PassiveTestTesterBase*>(callComp);
  return _testerBase->from_serialOut_handlerBase(
    portNum,
    buffer
  );
}
